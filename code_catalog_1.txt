
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Controls\BoolEditorControl.axaml.cs
================================================================================

using Avalonia.Markup.Xaml;

namespace Avalonia.UIStudio.Appearance.Controls;

public partial class BoolEditorControl : ValidatableEditorControlBase<TextEditorControl>
{
    public static readonly StyledProperty<bool> ValueProperty =
        AvaloniaProperty.Register<TextEditorControl, bool>(nameof(Value));

    public BoolEditorControl()
    {
        InitializeComponent();
    }

    public bool Value
    {
        get => GetValue(ValueProperty);
        set => SetValue(ValueProperty, value);
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Controls\ColorEditorControl.axaml.cs
================================================================================

using Avalonia.Markup.Xaml;
using Avalonia.Media;

namespace Avalonia.UIStudio.Appearance.Controls;

public partial class ColorEditorControl : ValidatableEditorControlBase<ColorEditorControl>
{
    public static readonly StyledProperty<Color> ValueProperty =
        AvaloniaProperty.Register<ColorEditorControl, Color>(nameof(Value));

    public ColorEditorControl()
    {
        InitializeComponent();
    }

    public Color Value
    {
        get => GetValue(ValueProperty);
        set => SetValue(ValueProperty, value);
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Controls\EnumEditorControl.axaml.cs
================================================================================

using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;

namespace Avalonia.UIStudio.Appearance.Controls;

public partial class EnumEditorControl : ValidatableEditorControlBase<EnumEditorControl>
{
    public static readonly StyledProperty<Enum?> ValueProperty =
        AvaloniaProperty.Register<EnumEditorControl, Enum?>(nameof(Value));

    public EnumEditorControl()
    {
        InitializeComponent();
    }

    public Enum? Value
    {
        get => GetValue(ValueProperty);
        set => SetValue(ValueProperty, value);
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Controls\FontFamilyEditorControl.axaml.cs
================================================================================

using System.Collections.ObjectModel;
using Avalonia.Markup.Xaml;
using Avalonia.Media;

namespace Avalonia.UIStudio.Appearance.Controls;

public partial class FontFamilyEditorControl : ValidatableEditorControlBase<FontFamilyEditorControl>
{
    public static readonly StyledProperty<FontFamily> ValueProperty =
        AvaloniaProperty.Register<FontFamilyEditorControl, FontFamily>(nameof(Value));

    public static readonly StyledProperty<ObservableCollection<FontFamily>> AvailableFontFamiliesProperty =
        AvaloniaProperty.Register<FontFamilyEditorControl, ObservableCollection<FontFamily>>(nameof(AvailableFontFamilies));

    public static readonly StyledProperty<FontFamily?> SuggestedValueProperty =
        AvaloniaProperty.Register<FontFamilyEditorControl, FontFamily?>(nameof(SuggestedValue));

    public FontFamilyEditorControl()
    {
        InitializeComponent();

        // Default font family list � you can customize or load from FontManager
        var fonts = FontManager.Current.SystemFonts.ToList();
        AvailableFontFamilies = new ObservableCollection<FontFamily>();
        foreach (var font in fonts) AvailableFontFamilies.Add(font.Name);
    }

    public FontFamily Value
    {
        get => GetValue(ValueProperty);
        set => SetValue(ValueProperty, value);
    }

    public ObservableCollection<FontFamily> AvailableFontFamilies
    {
        get => GetValue(AvailableFontFamiliesProperty);
        set => SetValue(AvailableFontFamiliesProperty, value);
    }

    public FontFamily? SuggestedValue
    {
        get => GetValue(SuggestedValueProperty);
        set => SetValue(SuggestedValueProperty, value);
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Controls\ModalLauncherControl.axaml.cs
================================================================================

using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Markup.Xaml;
using Avalonia.ReactiveUI;
using System;
using Avalonia.UIStudio.Appearance.Views;

namespace Avalonia.UIStudio.Appearance.Controls;

public partial class ModalEditorLauncherControl : ValidatableEditorControlBase<ModalEditorLauncherControl>
{
    public static readonly StyledProperty<object?> ValueProperty =
        AvaloniaProperty.Register<ModalEditorLauncherControl, object?>(nameof(Value));

    public static readonly StyledProperty<string> LaunchLabelProperty =
        AvaloniaProperty.Register<ModalEditorLauncherControl, string>(nameof(LaunchLabel), defaultValue: "Edit...");

    public ModalEditorLauncherControl()
    {
        InitializeComponent();
    }

    public object? Value
    {
        get => GetValue(ValueProperty);
        set => SetValue(ValueProperty, value);
    }

    public string LaunchLabel
    {
        get => GetValue(LaunchLabelProperty);
        set => SetValue(LaunchLabelProperty, value);
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }

    private async void LaunchEditor_Click(object? sender, Avalonia.Interactivity.RoutedEventArgs e)
    {
        if (Value == null)
            return;

        var window = new ModalEditorDialog(Value);
        await window.ShowDialog((Window)VisualRoot!);
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Controls\ModalListEditorLauncherControl.axaml.cs
================================================================================

using Avalonia.Controls;
using Avalonia.UIStudio.Appearance.Views;

namespace Avalonia.UIStudio.Appearance.Controls;

public partial class ModalListEditorLauncherControl : ValidatableEditorControlBase<ModalListEditorLauncherControl>
{
    public static readonly StyledProperty<object?> ValueProperty =
        AvaloniaProperty.Register<ModalListEditorLauncherControl, object?>(nameof(Value));

    public static readonly StyledProperty<string> LaunchLabelProperty =
        AvaloniaProperty.Register<ModalListEditorLauncherControl, string>(nameof(LaunchLabel), defaultValue: "Edit...");

    public ModalListEditorLauncherControl()
    {
        InitializeComponent();
    }

    public object? Value
    {
        get => GetValue(ValueProperty);
        set => SetValue(ValueProperty, value);
    }

    public string LaunchLabel
    {
        get => GetValue(LaunchLabelProperty);
        set => SetValue(LaunchLabelProperty, value);
    }

    private async void LaunchEditor_Click(object? sender, Avalonia.Interactivity.RoutedEventArgs e)
    {
        if (Value is not IEnumerable<object> list)
            return;

        var window = new ModalListEditorDialog(list);
        await window.ShowDialog((Window)VisualRoot!);
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Controls\NumericEditorControl.axaml.cs
================================================================================

using Avalonia.Markup.Xaml;

namespace Avalonia.UIStudio.Appearance.Controls;

public partial class NumericEditorControl : ValidatableEditorControlBase<NumericEditorControl>
{
    public static readonly StyledProperty<double> ValueProperty =
        AvaloniaProperty.Register<NumericEditorControl, double>(nameof(Value));

    public static readonly StyledProperty<double> MaximumProperty =
        AvaloniaProperty.Register<NumericEditorControl, double>(nameof(Maximum), 100.0);

    public static readonly StyledProperty<double> MinimumProperty =
        AvaloniaProperty.Register<NumericEditorControl, double>(nameof(Minimum));

    public static readonly StyledProperty<object?> SuggestedValueProperty =
        AvaloniaProperty.Register<NumericEditorControl, object?>(nameof(SuggestedValue));

    public NumericEditorControl()
    {
        InitializeComponent();
    }

    public double Value
    {
        get => GetValue(ValueProperty);
        set => SetValue(ValueProperty, value);
    }

    public double Maximum
    {
        get => GetValue(MaximumProperty);
        set => SetValue(MaximumProperty, value);
    }

    public double Minimum
    {
        get => GetValue(MinimumProperty);
        set => SetValue(MinimumProperty, value);
    }

    public object? SuggestedValue
    {
        get => GetValue(SuggestedValueProperty);
        set => SetValue(SuggestedValueProperty, value);
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Controls\PropertyGrid.axaml.cs
================================================================================

using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using Avalonia.Media;
using Avalonia.ReactiveUI;
using Avalonia.UIStudio.Appearance.Model;
using Avalonia.UIStudio.Appearance.Services;
using Avalonia.UIStudio.Appearance.ViewModels;
using ReactiveUI;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Reactive.Disposables;
using System.Reflection;
using System.Runtime.CompilerServices;

namespace Avalonia.UIStudio.Appearance.Controls;

public enum PropertyGridSortMode
{
    Alphabetical,
    ByType
}

public partial class PropertyGrid : ReactiveUserControl<PropertyGrid>, IReactiveObject, INotifyPropertyChanged
{
    public static readonly StyledProperty<object?> SelectedObjectProperty =
        AvaloniaProperty.Register<PropertyGrid, object?>(nameof(SelectedObject));

    public static readonly StyledProperty<bool> IsEditModeProperty =
        AvaloniaProperty.Register<PropertyGrid, bool>(nameof(IsEditMode));

    public static readonly StyledProperty<PropertyGridSortMode> SortModeProperty =
        AvaloniaProperty.Register<PropertyGrid, PropertyGridSortMode>(
            nameof(SortMode), defaultValue: PropertyGridSortMode.ByType);

    public PropertyGrid()
    {
        InitializeComponent();
        DataContext = this;

        this.GetObservable(SelectedObjectProperty).Subscribe(OnSelectedObjectChanged);
        this.GetObservable(SortModeProperty).Subscribe(_ => OnSelectedObjectChanged(SelectedObject));
    }

    public object? SelectedObject
    {
        get => GetValue(SelectedObjectProperty);
        set => SetValue(SelectedObjectProperty, value);
    }

    public bool IsEditMode
    {
        get => GetValue(IsEditModeProperty);
        set => SetValue(IsEditModeProperty, value);
    }

    public PropertyGridSortMode SortMode
    {
        get => GetValue(SortModeProperty);
        set => SetValue(SortModeProperty, value);
    }

    public List<PropertyGridSortMode> SortModes { get; } = new()
    {
        PropertyGridSortMode.Alphabetical,
        PropertyGridSortMode.ByType
    };

    private ObservableCollection<PropertyViewModel> _properties = new();
    public ObservableCollection<PropertyViewModel> Properties
    {
        get => _properties;
        set => RaiseAndSetIfChanged(ref _properties, value);
    }

    private ObservableCollection<PropertyGroupViewModel> _groupedProperties = new();
    public ObservableCollection<PropertyGroupViewModel> GroupedProperties
    {
        get => _groupedProperties;
        set => RaiseAndSetIfChanged(ref _groupedProperties, value);
    }

    private void OnSelectedObjectChanged(object? obj)
    {
        Properties = new ObservableCollection<PropertyViewModel>();
        GroupedProperties = new ObservableCollection<PropertyGroupViewModel>();

        if (obj == null) return;

        var props = obj.GetType()
            .GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .Where(p => p.CanRead && p.CanWrite)
            .Select(p => CreateViewModelForProperty(obj, p));

        if (SortMode == PropertyGridSortMode.Alphabetical)
        {
            Properties = new ObservableCollection<PropertyViewModel>(
                props.OrderBy(p => p.DisplayName)
            );
        }
        else
        {
            GroupedProperties = new ObservableCollection<PropertyGroupViewModel>(
                props.GroupBy(p => p.GroupName)
                     .OrderBy(g => g.Key)
                     .Select(g => new PropertyGroupViewModel(g.Key, g.OrderBy(p => p.DisplayName)))
            );
        }
    }

    private static PropertyViewModel CreateViewModelForProperty(object obj, PropertyInfo prop)
    {
        var type = prop.PropertyType;

        if (type == typeof(Color))
            return new ColorPropertyViewModel(obj, prop);
        if (type == typeof(double) || type == typeof(int))
            return new NumericPropertyViewModel(obj, prop);
        if (type == typeof(bool))
            return new BoolPropertyViewModel(obj, prop);
        if (type.IsEnum)
            return new EnumPropertyViewModel(obj, prop);
        if (type == typeof(string))
            return new StringPropertyViewModel(obj, prop);
        if (type == typeof(DateTime))
            return new DateTimePropertyViewModel(obj, prop);
        if (type == typeof(TimeSpan))
            return new TimeSpanPropertyViewModel(obj, prop);
        if (type == typeof(Uri))
            return new UriPropertyViewModel(obj, prop);
        if (type == typeof(FontFamily))
            return new FontFamilyPropertyViewModel(obj, prop);
        if (type == typeof(Thickness))
            return new ThicknessPropertyViewModel(obj, prop);
        if (type == typeof(SerializableTypography))
            return new TypographyPropertyViewModel(obj, prop);
        if (type == typeof(SerializableSkin))
            return new SkinPropertyViewModel(obj, prop);
        if (TypeHelpers.IsListOfStrings(type))
            return new StringListPropertyViewModel(obj, prop);
        if (TypeHelpers.IsListOfObjects(type))
            return new ObjectListPropertyViewModel(obj, prop);

        return new ObjectPropertyViewModel(obj, prop);
    }

    // ----- ReactiveUI glue -----

    public event PropertyChangingEventHandler? PropertyChanging;
    public event PropertyChangedEventHandler? PropertyChanged;

    void IReactiveObject.RaisePropertyChanged(PropertyChangedEventArgs args) =>
        PropertyChanged?.Invoke(this, args);

    void IReactiveObject.RaisePropertyChanging(PropertyChangingEventArgs args) =>
        PropertyChanging?.Invoke(this, args);

    

    protected bool RaiseAndSetIfChanged<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
    {
        if (EqualityComparer<T>.Default.Equals(field, value))
            return false;

        PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(propertyName));
        field = value;
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        return true;
    }
}

================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Controls\QuickSkinSwitcher.axaml.cs
================================================================================

using Avalonia.Controls;
using Avalonia.UIStudio.Appearance.Extensions;
using Avalonia.UIStudio.Appearance.Interfaces;
using Avalonia.UIStudio.Appearance.ViewModels;

namespace Avalonia.UIStudio.Appearance.Controls;

/// <summary>
///     Represents a user control that provides a quick skin switching functionality
///     for Avalonia applications. This control is designed to integrate seamlessly
///     with the Avalonia UI framework and is backed by the <see cref="QuickSkinSwitcherViewModel" />.
/// </summary>
public partial class QuickSkinSwitcher : UserControl
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="QuickSkinSwitcher" /> class.
    ///     This constructor sets up the control by initializing its components and
    ///     assigning a new instance of <see cref="QuickSkinSwitcherViewModel" /> as its data context.
    /// </summary>
    public QuickSkinSwitcher()
    {
        InitializeComponent();
        DataContext = AppBuilderExtensions.GetRequiredService<IQuickSkinSwitcherViewModel>();
    }

    public QuickSkinSwitcher(ISkinManager skinManager)
    {
        InitializeComponent();
        DataContext = new QuickSkinSwitcherViewModel(skinManager);
    }

    public QuickSkinSwitcher(IQuickSkinSwitcherViewModel viewModel)
    {
        InitializeComponent();
        DataContext = viewModel;
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Controls\TextEditorControl.axaml.cs
================================================================================

using Avalonia.Markup.Xaml;

namespace Avalonia.UIStudio.Appearance.Controls;

public partial class TextEditorControl : ValidatableEditorControlBase<TextEditorControl>
{
    public static readonly StyledProperty<string> ValueProperty =
        AvaloniaProperty.Register<TextEditorControl, string>(nameof(Value));

    public TextEditorControl()
    {
        InitializeComponent();
    }

    public string Value
    {
        get => GetValue(ValueProperty);
        set => SetValue(ValueProperty, value);
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Controls\ThicknessEditorControl.axaml.cs
================================================================================

using Avalonia;
using Avalonia.Markup.Xaml;
using Avalonia.UIStudio.Appearance.Controls;

namespace Avalonia.UIStudio.Appearance.Controls;

public partial class ThicknessEditorControl : ValidatableEditorControlBase<ThicknessEditorControl>
{
    public static readonly StyledProperty<Thickness> ValueProperty =
        AvaloniaProperty.Register<ThicknessEditorControl, Thickness>(nameof(Value));

    public ThicknessEditorControl()
    {
        InitializeComponent();
    }
    
    public string ValueString => $"{Value.Left}, {Value.Top}, {Value.Right}, {Value.Bottom}";

    public Thickness Value
    {
        get => GetValue(ValueProperty);
        set => SetValue(ValueProperty, value);
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Controls\ValidatableEditorControlBase.cs
================================================================================

// Controls/ValidatableEditorControlBase.cs

using Avalonia.Controls;
using Avalonia.UIStudio.Appearance.Model;

namespace Avalonia.UIStudio.Appearance.Controls;

public abstract class ValidatableEditorControlBase<TControl> : UserControl where TControl : UserControl
{
    public static readonly StyledProperty<ValidatedProperty?> ValidatedPropertyProperty =
        AvaloniaProperty.Register<TControl, ValidatedProperty?>(nameof(ValidatedProperty));

    public static readonly StyledProperty<string?> PropertyNameProperty =
        AvaloniaProperty.Register<TControl, string?>(nameof(PropertyName));

    public static readonly StyledProperty<string> LabelProperty =
        AvaloniaProperty.Register<TControl, string>(nameof(Label));

    public static readonly StyledProperty<bool> IsEditModeProperty =
        AvaloniaProperty.Register<TControl, bool>(nameof(IsEditMode));

    public ValidatedProperty? ValidatedProperty
    {
        get => GetValue(ValidatedPropertyProperty);
        set => SetValue(ValidatedPropertyProperty, value);
    }

    public string? PropertyName
    {
        get => GetValue(PropertyNameProperty);
        set => SetValue(PropertyNameProperty, value);
    }

    public string Label
    {
        get => GetValue(LabelProperty);
        set => SetValue(LabelProperty, value);
    }

    public bool IsEditMode
    {
        get => GetValue(IsEditModeProperty);
        set => SetValue(IsEditModeProperty, value);
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Controls\ValidationDecorator.cs
================================================================================

using Avalonia.Controls;
using Avalonia.UIStudio.Appearance.Model;

namespace Avalonia.UIStudio.Appearance.Controls;

public class ValidationDecorator : Decorator
{
    public static readonly StyledProperty<ValidatedProperty?> ValidatedPropertyProperty =
        AvaloniaProperty.Register<ValidationDecorator, ValidatedProperty?>(
            nameof(ValidatedProperty));

    public static readonly StyledProperty<string?> PropertyNameProperty =
        AvaloniaProperty.Register<ValidationDecorator, string?>(
            nameof(PropertyName));

    public ValidationDecorator()
    {
        DataContextChanged += ValidationDecorator_DataContextChanged;
    }

    public ValidatedProperty? ValidatedProperty
    {
        get => GetValue(ValidatedPropertyProperty);
        set => SetValue(ValidatedPropertyProperty, value);
    }

    public string? PropertyName
    {
        get => GetValue(PropertyNameProperty);
        set => SetValue(PropertyNameProperty, value);
    }

    private void ValidationDecorator_DataContextChanged(object? sender, EventArgs e)
    {
        if (DataContext is Dictionary<string, ValidatedProperty> propertys && PropertyName != null &&
            propertys.ContainsKey(PropertyName))
        {
            ValidatedProperty = propertys[PropertyName];
            DataContext = ValidatedProperty; // Key fix!
        }
        else
        {
            if (DataContext is ValidatedProperty validatedProperty) ValidatedProperty = validatedProperty;
        }
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Converters\AccentColorConverter.cs
================================================================================

using System.Globalization;
using Avalonia.Data.Converters;
using Avalonia.Media;

namespace Avalonia.UIStudio.Appearance.Converters
{
    /// <summary>
    /// Creates an accent color for a given base color value and step parameter.
    /// </summary>
    /// <remarks>
    /// This is a highly-specialized converter for the color picker.
    /// </remarks>
    public class AccentColorConverter : IValueConverter
    {
        /// <summary>
        /// The amount to change the Value component for each accent color step.
        /// </summary>
        public const double ValueDelta = 0.1;

        /// <inheritdoc/>
        public object? Convert(
            object? value,
            Type targetType,
            object? parameter,
            CultureInfo culture)
        {
            int accentStep;
            Color? rgbColor = null;
            HsvColor? hsvColor = null;

            if (value is Color valueColor)
            {
                rgbColor = valueColor;
            }
            else if (value is HslColor valueHslColor)
            {
                rgbColor = valueHslColor.ToRgb();
            }
            else if (value is HsvColor valueHsvColor)
            {
                hsvColor = valueHsvColor;
            }
            else if (value is SolidColorBrush valueBrush)
            {
                rgbColor = valueBrush.Color;
            }
            else
            {
                // Invalid color value provided
                return AvaloniaProperty.UnsetValue;
            }

            // Get the value component delta
            try
            {
                accentStep = int.Parse(parameter?.ToString() ?? "", CultureInfo.InvariantCulture);
            }
            catch
            {
                // Invalid parameter provided, unable to convert to integer
                return AvaloniaProperty.UnsetValue;
            }

            if (hsvColor == null &&
                rgbColor != null)
            {
                hsvColor = rgbColor.Value.ToHsv();
            }

            if (hsvColor != null)
            {
                return new SolidColorBrush(GetAccent(hsvColor.Value, accentStep).ToRgb());
            }
            else
            {
                return AvaloniaProperty.UnsetValue;
            }
        }

        /// <inheritdoc/>
        public object? ConvertBack(
            object? value,
            Type targetType,
            object? parameter,
            CultureInfo culture)
        {
            return AvaloniaProperty.UnsetValue;
        }

        /// <summary>
        /// This does not account for perceptual differences and also does not match with
        /// system accent color calculation.
        /// </summary>
        /// <remarks>
        /// Use the HSV representation as it's more perceptual.
        /// In most cases only the value is changed by a fixed percentage so the algorithm is reproducible.
        /// </remarks>
        /// <param name="hsvColor">The base color to calculate the accent from.</param>
        /// <param name="accentStep">The number of accent color steps to move.</param>
        /// <returns>The new accent color.</returns>
        public static HsvColor GetAccent(HsvColor hsvColor, int accentStep)
        {
            if (accentStep != 0)
            {
                double colorValue = hsvColor.V;
                colorValue += (accentStep * AccentColorConverter.ValueDelta);
                colorValue = Math.Round(colorValue, 2);

                return new HsvColor(hsvColor.A, hsvColor.H, hsvColor.S, colorValue);
            }
            else
            {
                return hsvColor;
            }
        }
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Converters\BoolToBorderBrushConverter.cs
================================================================================

using System.Globalization;
using Avalonia.Data.Converters;
using Avalonia.Media;

namespace Avalonia.UIStudio.Appearance.Converters;

public class BoolToBorderBrushConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is bool isError)
            return isError ? Brushes.Red : Brushes.Pink;
        return Brushes.Gray;
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        return value;
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Converters\BoolToEditModeContentConverter.cs
================================================================================

using System.Globalization;
using Avalonia.Data.Converters;

namespace Avalonia.UIStudio.Appearance.Converters;

public class BoolToEditModeContentConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        return value is bool isEdit && isEdit ? "Editing Skin" : "View Skin Info";
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        return value;
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Converters\ColorToDisplayNameConverter.cs
================================================================================

using System.Globalization;
using Avalonia.Controls.Primitives;
using Avalonia.Data.Converters;
using Avalonia.Media;

namespace Avalonia.UIStudio.Appearance.Converters
{
    /// <summary>
    /// Gets the approximated display name for the color.
    /// </summary>
    public class ColorToDisplayNameConverter : IValueConverter
    {
        /// <inheritdoc/>
        public object? Convert(
            object? value,
            Type targetType,
            object? parameter,
            CultureInfo culture)
        {
            Color color;

            if (value is Color valueColor)
            {
                color = valueColor;
            }
            else if (value is HslColor valueHslColor)
            {
                color = valueHslColor.ToRgb();
            }
            else if (value is HsvColor valueHsvColor)
            {
                color = valueHsvColor.ToRgb();
            }
            else if (value is SolidColorBrush valueBrush)
            {
                color = valueBrush.Color;
            }
            else
            {
                // Invalid color value provided
                return AvaloniaProperty.UnsetValue;
            }

            // ColorHelper.ToDisplayName ignores the alpha component
            // This means fully transparent colors will be named as a real color
            // That undesirable behavior is specially overridden here
            if (color.A == 0x00)
            {
                return AvaloniaProperty.UnsetValue;
            }
            else
            {
                return ColorHelper.ToDisplayName(color);
            }
        }

        /// <inheritdoc/>
        public object? ConvertBack(
            object? value,
            Type targetType,
            object? parameter,
            CultureInfo culture)
        {
            return AvaloniaProperty.UnsetValue;
        }
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Converters\ContrastBrushConverter.cs
================================================================================

using System.Globalization;
using Avalonia.Controls.Converters;
using Avalonia.Controls.Primitives;
using Avalonia.Data.Converters;
using Avalonia.Media;

namespace Avalonia.UIStudio.Appearance.Converters
{
    /// <summary>
    /// Gets a <see cref="SolidColorBrush"/>, either black or white, depending on the luminance of the supplied color.
    /// A default color supplied in the converter parameter may be returned if alpha is below the set threshold.
    /// </summary>
    /// <remarks>
    /// This is a highly-specialized converter for the color picker.
    /// </remarks>
    public class ContrastBrushConverter : IValueConverter
    {
        private ToColorConverter toColorConverter = new ToColorConverter();

        /// <summary>
        /// Gets or sets the alpha channel threshold below which a default color is used instead of black/white.
        /// </summary>
        public byte AlphaThreshold { get; set; } = 128;

        /// <inheritdoc/>
        public object? Convert(
            object? value,
            Type targetType,
            object? parameter,
            CultureInfo culture)
        {
            Color comparisonColor;
            Color? defaultColor = null;

            // Get the changing color to compare against
            var convertedValue = toColorConverter.Convert(value, targetType, parameter, culture);
            if (convertedValue is Color valueColor)
            {
                comparisonColor = valueColor;
            }
            else
            {
                // Invalid color value provided
                return AvaloniaProperty.UnsetValue;
            }

            // Get the default color when transparency is high
            var convertedParameter = toColorConverter.Convert(parameter, targetType, parameter, culture);
            if (convertedParameter is Color parameterColor)
            {
                defaultColor = parameterColor;
            }

            if (comparisonColor.A < AlphaThreshold &&
                defaultColor.HasValue)
            {
                // If the transparency is less than the threshold, just use the default brush
                // This can commonly be something like the TextControlForeground brush
                return new SolidColorBrush(defaultColor.Value);
            }
            else
            {
                // Chose a white/black brush based on contrast to the base color
                if (ColorHelper.GetRelativeLuminance(comparisonColor) <= 0.5)
                {
                    // Dark color, return light for contrast
                    return new SolidColorBrush(Colors.White);
                }
                else
                {
                    // Bright color, return dark for contrast
                    return new SolidColorBrush(Colors.Black);
                }
            }
        }

        /// <inheritdoc/>
        public object? ConvertBack(
            object? value,
            Type targetType,
            object? parameter,
            CultureInfo culture)
        {
            return AvaloniaProperty.UnsetValue;
        }
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Converters\CornerRadiusFilterConverter.cs
================================================================================

using System.Globalization;
using Avalonia.Controls.Converters;
using Avalonia.Data.Converters;

namespace Avalonia.UIStudio.Appearance.Converters
{
    /// <summary>
    /// Converts an existing CornerRadius struct to a new CornerRadius struct,
    /// with filters applied to extract only the specified corners, leaving the others set to 0.
    /// </summary>
    public class CornerRadiusFilterConverter : IValueConverter
    {
        /// <summary>
        /// Gets or sets the corners to filter by.
        /// Only the specified corners will be included in the converted <see cref="CornerRadius"/>.
        /// </summary>
        public Corners Filter { get; set; }

        /// <summary>
        /// Gets or sets the scale multiplier applied uniformly to each corner.
        /// </summary>
        public double Scale { get; set; } = 1;

        /// <inheritdoc/>
        public object? Convert(
            object? value,
            Type targetType,
            object? parameter,
            CultureInfo culture)
        {
            if (!(value is CornerRadius radius))
            {
                return value;
            }

            return new CornerRadius(
                Filter.HasAllFlags(Corners.TopLeft) ? radius.TopLeft * Scale : 0,
                Filter.HasAllFlags(Corners.TopRight) ? radius.TopRight * Scale : 0,
                Filter.HasAllFlags(Corners.BottomRight) ? radius.BottomRight * Scale : 0,
                Filter.HasAllFlags(Corners.BottomLeft) ? radius.BottomLeft * Scale : 0);
        }

        /// <inheritdoc/>
        public object? ConvertBack(
            object? value,
            Type targetType,
            object? parameter,
            CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    public static class EnumExtensions
    {
        public static bool HasAllFlags<T>(this T value, T flags) where T : Enum
        {
            var valueAsLong = Convert.ToInt64(value);
            var flagsAsLong = Convert.ToInt64(flags);
            return (valueAsLong & flagsAsLong) == flagsAsLong;
        }
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Converters\EnumToBoolConverter.cs
================================================================================

using System.Globalization;
using Avalonia.Data;
using Avalonia.Data.Converters;

namespace Avalonia.UIStudio.Appearance.Converters
{
    /// <summary>
    /// Converter to convert an enum value to bool by comparing to the given parameter.
    /// Both value and parameter must be of the same enum type.
    /// </summary>
    /// <remarks>
    /// This converter is useful to enable binding of radio buttons with a selected enum value.
    /// </remarks>
    public class EnumToBoolConverter : IValueConverter
    {
        /// <inheritdoc/>
        public object? Convert(
            object? value,
            Type targetType,
            object? parameter,
            CultureInfo culture)
        {
            if (value == null &&
                parameter == null)
            {
                return true;
            }
            else if (value == null ||
                     parameter == null)
            {
                return false;
            }
            else
            {
                return value.ToString()!.Equals(parameter);
            }
        }

        /// <inheritdoc/>
        public object? ConvertBack(
            object? value,
            Type targetType,
            object? parameter,
            CultureInfo culture)
        {
            if (value is bool boolValue &&
                boolValue == true)
            {
                return parameter;
            }

            return BindingOperations.DoNothing;
        }
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Converters\EnumValuesConverter.cs
================================================================================

using System;
using System.Globalization;
using Avalonia.Data.Converters;

namespace Avalonia.UIStudio.Appearance.Converters;

public class EnumValuesConverter : IValueConverter
{
    public static readonly EnumValuesConverter Instance = new();

    public object Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        return value is Enum enumVal ? Enum.GetValues(enumVal.GetType()) : Array.Empty<Enum>();
    }

    public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        return value;
    }
}

================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Converters\ObjectToColorConverter.cs
================================================================================

using System.Globalization;
using Avalonia.Data.Converters;
using Avalonia.Media;

namespace Avalonia.UIStudio.Appearance.Converters;

public class ObjectToColorConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is Color c)
            return c;

        if (value is string s && Color.TryParse(s, out var parsed))
            return parsed;

        return Colors.Transparent; // fallback if value is invalid
    }

    public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        return value;
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Converters\ToBrushConverter.cs
================================================================================

using System.Globalization;
using Avalonia.Data.Converters;
using Avalonia.Media;

namespace Avalonia.UIStudio.Appearance.Converters
{
    /// <summary>
    /// Converts the given value into an <see cref="IBrush"/> when a conversion is possible.
    /// </summary>
    public class ToBrushConverter : IValueConverter
    {
        /// <inheritdoc/>
        public object? Convert(
            object? value,
            Type targetType,
            object? parameter,
            CultureInfo culture)
        {
            if (value is IBrush brush)
            {
                return brush;
            }
            else if (value is Color valueColor)
            {
                return new SolidColorBrush(valueColor);
            }
            else if (value is HslColor valueHslColor)
            {
                return new SolidColorBrush(valueHslColor.ToRgb());
            }
            else if (value is HsvColor valueHsvColor)
            {
                return new SolidColorBrush(valueHsvColor.ToRgb());
            }

            return AvaloniaProperty.UnsetValue;
        }

        /// <inheritdoc/>
        public object? ConvertBack(
            object? value,
            Type targetType,
            object? parameter,
            CultureInfo culture)
        {
            return AvaloniaProperty.UnsetValue;
        }
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Extensions\AppBuilderExtensions.cs
================================================================================

using Avalonia.UIStudio.Appearance.Interfaces;
using Avalonia.UIStudio.Appearance.Model;
using Avalonia.UIStudio.Appearance.Services;
using Avalonia.UIStudio.Appearance.ViewModels;
using Avalonia.UIStudio.Appearance.Views;
using Microsoft.Extensions.DependencyInjection;

namespace Avalonia.UIStudio.Appearance.Extensions;

/// <summary>
///     Provides extension methods for configuring and integrating the AvaloniaSkinManager
///     into an Avalonia application using the <see cref="AppBuilder" />.
/// </summary>
/// <remarks>
///     This class contains methods to enable the AvaloniaSkinManager with default or custom configurations.
///     It simplifies the setup process by allowing developers to chain skin manager configuration
///     into the application initialization pipeline.
/// </remarks>
public static class AppBuilderExtensions
{
    /// <summary>
    ///     Static service provider holder for accessing services throughout the application
    /// </summary>
    private static IServiceProvider? _serviceProvider;

    /// <summary>
    ///     Action to be executed when application is ready
    /// </summary>
    private static Action? _initializationAction;

    /// <summary>
    ///     Gets the current service provider
    /// </summary>
    public static IServiceProvider ServiceProvider
    {
        get => _serviceProvider ?? throw new InvalidOperationException(
            "Service provider not initialized. Ensure UseSkinManager() was called during application setup.");
        private set => _serviceProvider = value;
    }

    /// <summary>
    ///     Adds AvaloniaSkinManager to the application with dependency injection support
    /// </summary>
    /// <param name="builder">The AppBuilder instance</param>
    /// <param name="configureServices">Optional service configuration action</param>
    /// <returns>The AppBuilder instance for method chaining</returns>
    public static AppBuilder UseSkinManager(this AppBuilder builder,
        Action<IServiceCollection>? configureServices = null, Action<IServiceProvider>? onBuilt = null)
    {
        return builder
            .AfterSetup(appBuilder =>
            {
                // Set up dependency injection
                var services = new ServiceCollection();

                // Add skin manager services
                services.AddSkinManagerServices();
                services.AddSingleton<IApplication>(_ =>
                    (IApplication)(Application.Current ??
                                   throw new InvalidOperationException("Application.Current is not available.")));
                services.AddTransient<IStylesCollection, AvaloniaStylesWrapper>();
                services.AddSingleton<ISkinLoaderService, SkinLoaderService>();
                services.AddTransient<ISkinImportExportService, SkinImportExportService>();
                services.AddSingleton<IQuickSkinSwitcherViewModel, QuickSkinSwitcherViewModel>();
                services.AddTransient<SkinSettingsViewModel>();
                services.AddTransient<SkinSettingsDialog>();
                services.AddSingleton<ISkinManager, SkinManager>();
                // Allow additional service configuration
                configureServices?.Invoke(services);

                // Build and store the service provider
                ServiceProvider = services.BuildServiceProvider();
                onBuilt?.Invoke(ServiceProvider); // Notify caller — they can assign App.Services here if they want


                // Store initialization action to be called when application is ready
                _initializationAction = () =>
                {
                    try
                    {
                        var skinManager = (SkinManager)ServiceProvider.GetRequiredService<ISkinManager>();
                        SkinManager.Instance = skinManager;
                        skinManager.LoadSavedSkin();
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error initializing skin manager: {ex.Message}");
                    }
                };
            });
    }

    /// <summary>
    ///     Adds AvaloniaSkinManager with custom configuration (legacy method for backward compatibility)
    /// </summary>
    /// <param name="builder">The AppBuilder instance</param>
    /// <param name="configure">Configuration action</param>
    /// <returns>The AppBuilder instance for method chaining</returns>
    public static AppBuilder UseSkinManager(this AppBuilder builder, Action<SkinManager> configure)
    {
        return builder.AfterSetup(appBuilder =>
        {
            // Set up dependency injection
            var services = new ServiceCollection();
            services.AddSkinManagerServices();
            ServiceProvider = services.BuildServiceProvider();

            // Store initialization action to be called when application is ready
            _initializationAction = () =>
            {
                try
                {
                    var skinManager = ServiceProvider.GetRequiredService<ISkinManager>() as SkinManager;
                    if (skinManager != null)
                    {
                        configure(skinManager);
                        skinManager.LoadSavedSkin();
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error configuring skin manager: {ex.Message}");
                }
            };
        });
    }

    /// <summary>
    ///     Internal method to be called by the Application when it's ready to initialize the skin manager
    ///     This should be called from Application.OnFrameworkInitializationCompleted()
    /// </summary>
    public static void InitializeSkinManager()
    {
        _initializationAction?.Invoke();
        _initializationAction = null; // Clear after execution
    }

    /// <summary>
    ///     Gets a service from the application's service provider
    /// </summary>
    /// <typeparam name="T">The service type</typeparam>
    /// <returns>The service instance</returns>
    /// <exception cref="InvalidOperationException">Thrown when the service provider is not available</exception>
    public static T GetRequiredService<T>() where T : notnull
    {
        return ServiceProvider.GetRequiredService<T>();
    }

    /// <summary>
    ///     Gets a service from the application's service provider
    /// </summary>
    /// <typeparam name="T">The service type</typeparam>
    /// <returns>The service instance, or null if not found</returns>
    public static T? GetService<T>() where T : class
    {
        try
        {
            return ServiceProvider.GetService<T>();
        }
        catch (InvalidOperationException)
        {
            return null;
        }
    }

    /// <summary>
    ///     Extension method for Application to get services (for compatibility)
    /// </summary>
    /// <typeparam name="T">The service type</typeparam>
    /// <param name="app">The application instance</param>
    /// <returns>The service instance</returns>
    public static T GetRequiredService<T>(this Application app) where T : notnull
    {
        return GetRequiredService<T>();
    }

    /// <summary>
    ///     Extension method for Application to get services (for compatibility)
    /// </summary>
    /// <typeparam name="T">The service type</typeparam>
    /// <param name="app">The application instance</param>
    /// <returns>The service instance, or null if not found</returns>
    public static T? GetService<T>(this Application app) where T : class
    {
        return GetService<T>();
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Extensions\ApplicationExtensions.cs
================================================================================

using Avalonia.Markup.Xaml.Styling;

namespace Avalonia.UIStudio.Appearance.Extensions;

/// <summary>
///     Provides extension methods for the <see cref="Avalonia.Application" /> class to integrate AvaloniaSkinManager
///     functionality.
/// </summary>
public static class ApplicationExtensions
{
    /// <summary>
    ///     Include AvaloniaSkinManager skins in your application
    /// </summary>
    /// <param name="app">The Application instance</param>
    /// <returns>The Application instance for method chaining</returns>
    public static Application IncludeSkinManagerStyles(this Application app)
    {
        app.Resources.MergedDictionaries.Add(new ResourceInclude(new Uri("avares://Avalonia.UIStudio.Appearance/"))
        {
            Source = new Uri("avares://Avalonia.UIStudio.Appearance/Skins/AppSkin.axaml")
        });

        return app;
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Extensions\ServiceCollectionExtension.cs
================================================================================

using Avalonia.UIStudio.Appearance.Interfaces;
using Avalonia.UIStudio.Appearance.Model;
using Avalonia.UIStudio.Appearance.Services;
using Avalonia.UIStudio.Appearance.Services.ValidationRules;
using Avalonia.UIStudio.Appearance.ViewModels;
using Microsoft.Extensions.DependencyInjection;
using PropertyGrid = Avalonia.UIStudio.Appearance.Controls.PropertyGrid;

namespace Avalonia.UIStudio.Appearance.Extensions;

/// <summary>
///     Provides extension methods for registering skin manager services in an Avalonia application.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    ///     Adds skin manager and related services to the service collection.
    /// </summary>
    /// <param name="services">The service collection to add services to.</param>
    /// <returns>The updated service collection.</returns>
    public static IServiceCollection AddSkinManagerServices(this IServiceCollection services)
    {
        // Logging (you can customize levels elsewhere if needed)
        services.AddLogging();


        // Application abstraction
        services.AddSingleton<IApplication, ApplicationWrapper>();
        services.AddSingleton<ISkinImportExportService, SkinImportExportService>();
        // Core services
        services.AddSingleton<ISkinLoaderService, SkinLoaderService>();
        services.AddSingleton<ISkinManager, SkinManager>();

        // Skin inheritance manager
        services.AddSingleton<SkinInheritanceManager>();

        // Validation rules
        services.AddSingleton<ISkinValidationRule, BorderValidationRule>();
        services.AddSingleton<ISkinValidationRule, ColorContrastValidationRule>();
        services.AddSingleton<ISkinValidationRule, NameValidationRule>();
        services.AddSingleton<ISkinValidationRule, AccessibilityValidationRule>();

        // ViewModels
        services.AddTransient<SkinSettingsViewModel>();
        services.AddTransient<QuickSkinSwitcherViewModel>();
        services.AddTransient<PropertyGrid>();

        return services;
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Extensions\TypographyExtensions.cs
================================================================================

using Avalonia.UIStudio.Appearance.Model;

namespace Avalonia.UIStudio.Appearance.Extensions;

public static class TypographyExtensions
{
    public static SerializableTypography? ToSerializable(this TypographyScale? scale, Skin skin)
    {
        if (scale == null)
            return null;

        return new SerializableTypography
        {
            DisplayLarge = scale.DisplayLarge,
            DisplayMedium = scale.DisplayMedium,
            DisplaySmall = scale.DisplaySmall,
            HeadlineLarge = scale.HeadlineLarge,
            HeadlineMedium = scale.HeadlineMedium,
            HeadlineSmall = scale.HeadlineSmall,
            TitleLarge = scale.TitleLarge,
            TitleMedium = scale.TitleMedium,
            TitleSmall = scale.TitleSmall,
            LabelLarge = scale.LabelLarge,
            LabelMedium = scale.LabelMedium,
            LabelSmall = scale.LabelSmall,
            BodyLarge = scale.BodyLarge,
            BodyMedium = scale.BodyMedium,
            BodySmall = scale.BodySmall,

            HeaderFontFamily = skin.HeaderFontFamily?.ToString(),
            BodyFontFamily = skin.BodyFontFamily?.ToString(),
            MonospaceFontFamily = skin.MonospaceFontFamily?.ToString(),

            LineHeight = skin.LineHeight,
            LetterSpacing = skin.LetterSpacing,
            EnableLigatures = skin.EnableLigatures
        };
    }

    public static TypographyScale ToTypographyScale(this SerializableTypography serial)
    {
        return new TypographyScale
        {
            DisplayLarge = serial.DisplayLarge,
            DisplayMedium = serial.DisplayMedium,
            DisplaySmall = serial.DisplaySmall,
            HeadlineLarge = serial.HeadlineLarge,
            HeadlineMedium = serial.HeadlineMedium,
            HeadlineSmall = serial.HeadlineSmall,
            TitleLarge = serial.TitleLarge,
            TitleMedium = serial.TitleMedium,
            TitleSmall = serial.TitleSmall,
            LabelLarge = serial.LabelLarge,
            LabelMedium = serial.LabelMedium,
            LabelSmall = serial.LabelSmall,
            BodyLarge = serial.BodyLarge,
            BodyMedium = serial.BodyMedium,
            BodySmall = serial.BodySmall
        };
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Interfaces\IApplication.cs
================================================================================

using Avalonia.Controls;
using Avalonia.Controls.ApplicationLifetimes;

namespace Avalonia.UIStudio.Appearance.Interfaces;

public interface IApplication
{
    IResourceDictionary Resources { get; }
    IApplicationLifetime? ApplicationLifetime { get; }
    IStylesCollection AppStyles { get; }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Interfaces\IQuickSkinSwitcherViewModel.cs
================================================================================

using System.Collections.ObjectModel;
using System.ComponentModel;
using Avalonia.UIStudio.Appearance.Model;
using Avalonia.UIStudio.Appearance.Services;
using ReactiveUI;

namespace Avalonia.UIStudio.Appearance.Interfaces;

public interface IQuickSkinSwitcherViewModel
{
    /// <summary>
    ///     Gets the collection of available skins that can be selected and applied
    ///     within the application.
    /// </summary>
    /// <remarks>
    ///     This property is populated by the <see cref="LoadAvailableskins" /> method,
    ///     which retrieves the skins from the <see cref="SkinManager" />. The collection
    ///     is updated dynamically to reflect the available skins.
    /// </remarks>
    ObservableCollection<SkinSummaryInfo> AvailableSkins { get; }

    /// <summary>
    ///     Gets or sets the currently selected skin.
    /// </summary>
    /// <remarks>
    ///     When a new skin is selected, the corresponding skin is applied automatically.
    ///     The selected skin is synchronized with the <see cref="AvailableSkins" /> collection.
    /// </remarks>
    SkinSummaryInfo? SelectedSkin { get; set; }

    IObservable<IReactivePropertyChangedEventArgs<IReactiveObject>> Changing { get; }
    IObservable<IReactivePropertyChangedEventArgs<IReactiveObject>> Changed { get; }
    IObservable<Exception> ThrownExceptions { get; }

    /// <summary>
    ///     Releases all resources used by the <see cref="ViewModelBase" /> instance.
    /// </summary>
    /// <remarks>
    ///     This method calls the <see cref="Dispose(bool)" /> method with a value of <c>true</c>
    ///     to release managed resources and suppresses finalization of the object.
    /// </remarks>
    void Dispose();

    IDisposable SuppressChangeNotifications();
    bool AreChangeNotificationsEnabled();
    IDisposable DelayChangeNotifications();
    event PropertyChangingEventHandler? PropertyChanging;
    event PropertyChangedEventHandler? PropertyChanged;
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Interfaces\ISkinImportExportService.cs
================================================================================

using Avalonia.UIStudio.Appearance.Model;

namespace Avalonia.UIStudio.Appearance.Interfaces;

public interface ISkinImportExportService
{
    Task<bool> ExportSkinAsync(Skin skin, string filePath, string? description = null, string? author = null);
    Task<bool> ExportAdvancedSkinAsync(Skin skin, string filePath, string? description = null, string? author = null);

    Task<bool> ExportInheritableSkinAsync(InheritableSkin skin, string filePath, string? description = null,
        string? author = null);

    Task<SkinImportResult> ImportSkinAsync(string filePath);
    Task<Skin?> ImportAdvancedSkinAsync(string filePath);
    Task<InheritableSkin?> ImportInheritableSkinAsync(string filePath);
    Task<SkinValidationResult> ValidateSkinFileAsync(string filePath);

    Task<bool> ExportSkinPackAsync(Dictionary<string, Skin> skins, string filePath, string packName,
        string? description = null);
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Interfaces\ISkinManager.cs
================================================================================

using Avalonia.UIStudio.Appearance.Model;

namespace Avalonia.UIStudio.Appearance.Interfaces;

/// <summary>
/// </summary>
public interface ISkinManager
{
    /// <summary>
    /// </summary>
    Skin? CurrentSkin { get; }

    /// <summary>
    /// </summary>
    event EventHandler? SkinChanged;

    /// <summary>
    /// </summary>
    /// <param name="name"></param>
    /// <param name="skin"></param>
    void RegisterSkin(string? name, Skin? skin);

    /// <summary>
    /// </summary>
    /// <param name="name"></param>
    /// <returns></returns>
    Skin? GetSkin(string? name);

    /// <summary>
    /// </summary>
    /// <returns></returns>
    List<string> GetAvailableSkinNames();

    /// <summary>
    /// </summary>
    /// <param name="skinName"></param>
    void ApplySkin(string? skinName);

    /// <summary>
    /// </summary>
    /// <param name="skin"></param>
    void ApplySkin(Skin? skin);

    /// <summary>
    /// </summary>
    /// <param name="skinName"></param>
    void SaveSelectedSkin(string? skinName);

    /// <summary>
    /// </summary>
    void LoadSavedSkin();

    string GetSkinFilePath(Skin skin);

    void ReloadSkins();
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Interfaces\ISkinValidationRule.cs
================================================================================

using Avalonia.UIStudio.Appearance.Model;

namespace Avalonia.UIStudio.Appearance.Interfaces;

/// <summary>
/// </summary>
public interface ISkinValidationRule
{
    List<SkinValidationMessage> Validate(Skin skin);
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Interfaces\IStylesCollection.cs
================================================================================

using Avalonia.Styling;

namespace Avalonia.UIStudio.Appearance.Interfaces;

/// <summary>
/// </summary>
public interface IStylesCollection : IEnumerable<IStyle>
{
    int Count { get; }
    void Add(IStyle style);
    bool Remove(IStyle style);
    void Clear();
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Model\ApplicationWrapper.cs
================================================================================

using Avalonia.Controls;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.UIStudio.Appearance.Interfaces;

namespace Avalonia.UIStudio.Appearance.Model;

public class ApplicationWrapper : IApplication
{
    private readonly Application _application;

    public ApplicationWrapper()
    {
        _application = Application.Current ??
                       throw new InvalidOperationException("Application.Current must not be null.");
        AppStyles = new AvaloniaStylesWrapper(_application.Styles);
    }

    public ApplicationWrapper(Application application)
    {
        _application = application ?? throw new ArgumentNullException(nameof(application));
        // Remove the asterisks - they're syntax errors
        AppStyles = new AvaloniaStylesWrapper(application.Styles);
    }

    public IResourceDictionary Resources => _application.Resources;
    public IApplicationLifetime? ApplicationLifetime => _application.ApplicationLifetime;
    public IStylesCollection AppStyles { get; }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Model\AppSettings.cs
================================================================================

using Newtonsoft.Json;

namespace Avalonia.UIStudio.Appearance.Model;

/// <summary>
///     Represents the application settings for the Avalonia Skin Manager.
///     Provides functionality to load, save, and manage skin-related settings.
/// </summary>
public class AppSettings
{
    private const string SettingsFileName = "appsettings.json";
    private static readonly string SettingsFilePath;
    private static AppSettings? _instance;

    // Update the static constructor in AppSettings.cs
    static AppSettings()
    {
        string appDataFolder;

        try
        {
            // Try to use a more appropriate app data folder
            appDataFolder = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
                "Avalonia.UIStudio.Appearance");
        }
        catch
        {
            // Fallback to current directory if permissions issue
            appDataFolder = Path.Combine(AppContext.BaseDirectory, "Settings");
        }

        if (!Directory.Exists(appDataFolder))
            try
            {
                Directory.CreateDirectory(appDataFolder);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Warning: Could not create settings directory: {ex.Message}");
                // Fallback to temp directory
                appDataFolder = Path.GetTempPath();
            }

        SettingsFilePath = Path.Combine(appDataFolder, SettingsFileName);
    }

    /// <summary>
    ///     Gets or sets the name of the currently selected skin.
    /// </summary>
    /// <value>
    ///     A <see cref="string" /> representing the skin name. The default value is "Dark".
    /// </value>
    /// <remarks>
    ///     This property is used to store the name of the skin selected by the user.
    ///     It can be updated dynamically and is persisted using the <see cref="AppSettings.Save" /> method.
    /// </remarks>
    public string? Skin { get; set; } = "Dark";

    // Add other settings as needed
    /// <summary>
    ///     Gets or sets a value indicating whether the application should use the system's default skin.
    /// </summary>
    /// <value>
    ///     <c>true</c> if the application should use the system's skin; otherwise, <c>false</c>.
    /// </value>
    public bool UseSystemskin { get; set; } = false;

    /// <summary>
    ///     Gets the singleton instance of the <see cref="AppSettings" /> class.
    /// </summary>
    /// <remarks>
    ///     This property ensures that only one instance of <see cref="AppSettings" /> exists throughout the application.
    ///     If the instance is not already initialized, it will be loaded using the <c>Load</c> method.
    /// </remarks>
    public static AppSettings Instance
    {
        get
        {
            if (_instance == null) _instance = Load();
            return _instance;
        }
    }

    private static AppSettings Load()
    {
        try
        {
            if (File.Exists(SettingsFilePath))
            {
                var json = File.ReadAllText(SettingsFilePath);
                var settings = JsonConvert.DeserializeObject<AppSettings>(json);
                if (settings != null)
                    return settings;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading settings: {ex.Message}");
        }

        // Return default settings if loading fails
        return new AppSettings();
    }

    /// <summary>
    ///     Saves the current application settings to a file.
    /// </summary>
    /// <remarks>
    ///     This method serializes the current instance of <see cref="AppSettings" /> into a JSON format
    ///     and writes it to the file specified by the settings file path. If an error occurs during
    ///     the save operation, it is logged to the console.
    /// </remarks>
    /// <exception cref="System.IO.IOException">
    ///     Thrown when an I/O error occurs while writing to the file.
    /// </exception>
    /// <exception cref="Newtonsoft.Json.JsonException">
    ///     Thrown when an error occurs during JSON serialization.
    /// </exception>
    public void Save()
    {
        try
        {
            var json = JsonConvert.SerializeObject(this, Formatting.Indented);
            File.WriteAllText(SettingsFilePath, json);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving settings: {ex.Message}");
        }
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Model\AvaloniaStylesWrapper.cs
================================================================================

using System.Collections;
using Avalonia.Styling;
using Avalonia.UIStudio.Appearance.Interfaces;

namespace Avalonia.UIStudio.Appearance.Model;

public class AvaloniaStylesWrapper : IStylesCollection
{
    private readonly Styles _styles;

    public AvaloniaStylesWrapper(Styles styles)
    {
        _styles = styles ?? throw new ArgumentNullException(nameof(styles));
    }

    public void Add(IStyle style)
    {
        _styles.Add(style);
    }

    public bool Remove(IStyle style)
    {
        return _styles.Remove(style);
    }

    public void Clear()
    {
        _styles.Clear();
    }

    // Fix: Make this a property, not a method, and delegate to the actual Styles collection
    public int Count => _styles.Count;

    public IEnumerator<IStyle> GetEnumerator()
    {
        return _styles.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Model\InheritableSkin.cs
================================================================================

using System.Text.Json;
using Avalonia.Media;

namespace Avalonia.UIStudio.Appearance.Model;

/// <summary>
///     Represents a skin that can inherit from a base skin and override specific properties.
/// </summary>
public class InheritableSkin : Skin
{
    private readonly HashSet<string> _setProperties = new();

    /// <summary>
    ///     Initializes a new instance of the InheritableSkin class.
    /// </summary>
    public InheritableSkin()
    {
        // Don't call base constructor to avoid setting default values
        // Initialize collections that are required
        ControlThemeUris = new List<string>();
        StyleUris = new List<string>();
        Typography = new TypographyScale();
        PropertyOverrides = new Dictionary<string, object>();
    }

    /// <summary>
    ///     Gets or sets the name of the base skin this skin inherits from.
    /// </summary>
    public string? BaseSkinName { get; set; }

    /// <summary>
    ///     Gets or sets the collection of property overrides for this skin.
    /// </summary>
    public Dictionary<string, object>? PropertyOverrides { get; set; } = new();

    // Override property setters to track which properties have been explicitly set
    public new Color PrimaryColor
    {
        get => base.PrimaryColor;
        set
        {
            base.PrimaryColor = value;
            _setProperties.Add(nameof(PrimaryColor));
        }
    }

    public new Color SecondaryColor
    {
        get => base.SecondaryColor;
        set
        {
            base.SecondaryColor = value;
            _setProperties.Add(nameof(SecondaryColor));
        }
    }

    public new Color AccentColor
    {
        get => base.AccentColor;
        set
        {
            base.AccentColor = value;
            _setProperties.Add(nameof(AccentColor));
        }
    }

    public new Color PrimaryBackground
    {
        get => base.PrimaryBackground;
        set
        {
            base.PrimaryBackground = value;
            _setProperties.Add(nameof(PrimaryBackground));
        }
    }

    public new Color SecondaryBackground
    {
        get => base.SecondaryBackground;
        set
        {
            base.SecondaryBackground = value;
            _setProperties.Add(nameof(SecondaryBackground));
        }
    }

    public new Color PrimaryTextColor
    {
        get => base.PrimaryTextColor;
        set
        {
            base.PrimaryTextColor = value;
            _setProperties.Add(nameof(PrimaryTextColor));
        }
    }

    public new Color SecondaryTextColor
    {
        get => base.SecondaryTextColor;
        set
        {
            base.SecondaryTextColor = value;
            _setProperties.Add(nameof(SecondaryTextColor));
        }
    }

    public new FontFamily FontFamily
    {
        get => base.FontFamily;
        set
        {
            base.FontFamily = value;
            _setProperties.Add(nameof(FontFamily));
        }
    }

    public new double FontSizeSmall
    {
        get => base.FontSizeSmall;
        set
        {
            base.FontSizeSmall = value;
            _setProperties.Add(nameof(FontSizeSmall));
        }
    }

    public new double FontSizeMedium
    {
        get => base.FontSizeMedium;
        set
        {
            base.FontSizeMedium = value;
            _setProperties.Add(nameof(FontSizeMedium));
        }
    }

    public new double FontSizeLarge
    {
        get => base.FontSizeLarge;
        set
        {
            base.FontSizeLarge = value;
            _setProperties.Add(nameof(FontSizeLarge));
        }
    }

    public new FontWeight FontWeight
    {
        get => base.FontWeight;
        set
        {
            base.FontWeight = value;
            _setProperties.Add(nameof(FontWeight));
        }
    }

    public new Color BorderColor
    {
        get => base.BorderColor;
        set
        {
            base.BorderColor = value;
            _setProperties.Add(nameof(BorderColor));
        }
    }

    public new Thickness BorderThickness
    {
        get => base.BorderThickness;
        set
        {
            base.BorderThickness = value;
            _setProperties.Add(nameof(BorderThickness));
        }
    }

    public new double BorderRadius
    {
        get => base.BorderRadius;
        set
        {
            base.BorderRadius = value;
            _setProperties.Add(nameof(BorderRadius));
        }
    }

    public new Color ErrorColor
    {
        get => base.ErrorColor;
        set
        {
            base.ErrorColor = value;
            _setProperties.Add(nameof(ErrorColor));
        }
    }

    public new Color WarningColor
    {
        get => base.WarningColor;
        set
        {
            base.WarningColor = value;
            _setProperties.Add(nameof(WarningColor));
        }
    }

    public new Color SuccessColor
    {
        get => base.SuccessColor;
        set
        {
            base.SuccessColor = value;
            _setProperties.Add(nameof(SuccessColor));
        }
    }

    public new string? Name
    {
        get => base.Name;
        set
        {
            base.Name = value;
            _setProperties.Add(nameof(Name));
        }
    }

    public new FontFamily? HeaderFontFamily
    {
        get => base.HeaderFontFamily;
        set
        {
            base.HeaderFontFamily = value;
            _setProperties.Add(nameof(HeaderFontFamily));
        }
    }

    public new FontFamily? BodyFontFamily
    {
        get => base.BodyFontFamily;
        set
        {
            base.BodyFontFamily = value;
            _setProperties.Add(nameof(BodyFontFamily));
        }
    }

    public new FontFamily? MonospaceFontFamily
    {
        get => base.MonospaceFontFamily;
        set
        {
            base.MonospaceFontFamily = value;
            _setProperties.Add(nameof(MonospaceFontFamily));
        }
    }

    public new double LineHeight
    {
        get => base.LineHeight;
        set
        {
            base.LineHeight = value;
            _setProperties.Add(nameof(LineHeight));
        }
    }

    public new double LetterSpacing
    {
        get => base.LetterSpacing;
        set
        {
            base.LetterSpacing = value;
            _setProperties.Add(nameof(LetterSpacing));
        }
    }

    public new bool EnableLigatures
    {
        get => base.EnableLigatures;
        set
        {
            base.EnableLigatures = value;
            _setProperties.Add(nameof(EnableLigatures));
        }
    }

    public new List<string> AssetUris
    {
        get => base.AssetUris;
        set
        {
            base.AssetUris = value;
            _setProperties.Add(nameof(AssetUris));
        }
    }

    public new string Description
    {
        get => base.Description;
        set
        {
            base.Description = value;
            _setProperties.Add(nameof(Description));
        }
    }

    /// <summary>
    ///     Creates a resolved skin by applying inheritance and overrides.
    /// </summary>
    /// <param name="baseSkin">The base skin to inherit from.</param>
    /// <returns>A fully resolved Skin with all properties applied.</returns>
    public Skin CreateResolvedSkin(Skin? baseSkin = null)
    {
        var resolved = new Skin();

        // Start with base skin if provided
        if (baseSkin != null) CopyPropertiesFrom(resolved, baseSkin);

        // Apply current skin's explicitly set properties only
        CopySetPropertiesFrom(resolved, this);

        // Apply property overrides
        ApplyOverrides(resolved);

        return resolved;
    }

    private void CopyPropertiesFrom(Skin target, Skin source)
    {
        target.PrimaryColor = source.PrimaryColor;
        target.SecondaryColor = source.SecondaryColor;
        target.AccentColor = source.AccentColor;
        target.PrimaryBackground = source.PrimaryBackground;
        target.SecondaryBackground = source.SecondaryBackground;
        target.PrimaryTextColor = source.PrimaryTextColor;
        target.SecondaryTextColor = source.SecondaryTextColor;

        target.FontFamily = source.FontFamily;
        target.FontSizeSmall = source.FontSizeSmall;
        target.FontSizeMedium = source.FontSizeMedium;
        target.FontSizeLarge = source.FontSizeLarge;
        target.FontWeight = source.FontWeight;

        target.HeaderFontFamily = source.HeaderFontFamily;
        target.BodyFontFamily = source.BodyFontFamily;
        target.MonospaceFontFamily = source.MonospaceFontFamily;

        target.LineHeight = source.LineHeight;
        target.LetterSpacing = source.LetterSpacing;
        target.EnableLigatures = source.EnableLigatures;

        target.BorderColor = source.BorderColor;
        target.BorderThickness = source.BorderThickness;
        target.BorderRadius = source.BorderRadius;

        target.ErrorColor = source.ErrorColor;
        target.WarningColor = source.WarningColor;
        target.SuccessColor = source.SuccessColor;

        target.ControlThemeUris = new List<string>(source.ControlThemeUris);
        target.StyleUris = new List<string>(source.StyleUris);
        target.AssetUris = new List<string>(source.AssetUris);
        target.Typography = source.Typography;
        target.Name = source.Name;
        target.Description = source.Description;
    }

    private void CopySetPropertiesFrom(Skin target, InheritableSkin source)
    {
        if (_setProperties.Contains(nameof(PrimaryColor)))
            target.PrimaryColor = source.PrimaryColor;
        if (_setProperties.Contains(nameof(SecondaryColor)))
            target.SecondaryColor = source.SecondaryColor;
        if (_setProperties.Contains(nameof(AccentColor)))
            target.AccentColor = source.AccentColor;
        if (_setProperties.Contains(nameof(PrimaryBackground)))
            target.PrimaryBackground = source.PrimaryBackground;
        if (_setProperties.Contains(nameof(SecondaryBackground)))
            target.SecondaryBackground = source.SecondaryBackground;
        if (_setProperties.Contains(nameof(PrimaryTextColor)))
            target.PrimaryTextColor = source.PrimaryTextColor;
        if (_setProperties.Contains(nameof(SecondaryTextColor)))
            target.SecondaryTextColor = source.SecondaryTextColor;

        if (_setProperties.Contains(nameof(FontFamily)))
            target.FontFamily = source.FontFamily;
        if (_setProperties.Contains(nameof(FontSizeSmall)))
            target.FontSizeSmall = source.FontSizeSmall;
        if (_setProperties.Contains(nameof(FontSizeMedium)))
            target.FontSizeMedium = source.FontSizeMedium;
        if (_setProperties.Contains(nameof(FontSizeLarge)))
            target.FontSizeLarge = source.FontSizeLarge;
        if (_setProperties.Contains(nameof(FontWeight)))
            target.FontWeight = source.FontWeight;

        if (_setProperties.Contains(nameof(HeaderFontFamily)))
            target.HeaderFontFamily = source.HeaderFontFamily;
        if (_setProperties.Contains(nameof(BodyFontFamily)))
            target.BodyFontFamily = source.BodyFontFamily;
        if (_setProperties.Contains(nameof(MonospaceFontFamily)))
            target.MonospaceFontFamily = source.MonospaceFontFamily;

        if (_setProperties.Contains(nameof(LineHeight)))
            target.LineHeight = source.LineHeight;
        if (_setProperties.Contains(nameof(LetterSpacing)))
            target.LetterSpacing = source.LetterSpacing;
        if (_setProperties.Contains(nameof(EnableLigatures)))
            target.EnableLigatures = source.EnableLigatures;

        if (_setProperties.Contains(nameof(BorderColor)))
            target.BorderColor = source.BorderColor;
        if (_setProperties.Contains(nameof(BorderThickness)))
            target.BorderThickness = source.BorderThickness;
        if (_setProperties.Contains(nameof(BorderRadius)))
            target.BorderRadius = source.BorderRadius;

        if (_setProperties.Contains(nameof(ErrorColor)))
            target.ErrorColor = source.ErrorColor;
        if (_setProperties.Contains(nameof(WarningColor)))
            target.WarningColor = source.WarningColor;
        if (_setProperties.Contains(nameof(SuccessColor)))
            target.SuccessColor = source.SuccessColor;

        if (_setProperties.Contains(nameof(ControlThemeUris)))
            target.ControlThemeUris = new List<string>(source.ControlThemeUris);
        if (_setProperties.Contains(nameof(StyleUris)))
            target.StyleUris = new List<string>(source.StyleUris);
        if (_setProperties.Contains(nameof(AssetUris)))
            target.AssetUris = new List<string>(source.AssetUris);
        if (_setProperties.Contains(nameof(Typography)))
            target.Typography = source.Typography;

        if (_setProperties.Contains(nameof(Name)))
            target.Name = source.Name;
        if (_setProperties.Contains(nameof(Description)))
            target.Description = source.Description;
    }

    private void ApplyOverrides(Skin target)
    {
        if (PropertyOverrides != null)
            foreach (var kvp in PropertyOverrides)
            {
                var property = typeof(Skin).GetProperty(kvp.Key);
                if (property != null && property.CanWrite)
                    try
                    {
                        var value = ConvertValue(kvp.Value, property.PropertyType);
                        property.SetValue(target, value);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Failed to apply override for {kvp.Key}: {ex.Message}");
                    }
            }
    }

    // Update the ConvertValue method in InheritableSkin.cs
    private object? ConvertValue(object? value, Type targetType)
    {
        if (value == null) return null;

        if (targetType == typeof(Color) && value is string colorString) return Color.Parse(colorString);

        if (targetType == typeof(FontFamily) && value is string fontString) return new FontFamily(fontString);

        if (targetType == typeof(FontWeight) && value is string fontWeightString)
            return Enum.TryParse<FontWeight>(fontWeightString, out var weight)
                ? weight
                : FontWeight.Normal;

        if (targetType == typeof(Thickness))
        {
            if (value is JsonElement element)
            {
                if (element.ValueKind == JsonValueKind.Number) return new Thickness(element.GetDouble());

                if (element.ValueKind == JsonValueKind.String) return Thickness.Parse(element.GetString() ?? "0");

                if (element.ValueKind == JsonValueKind.Object)
                {
                    var left = element.TryGetProperty("left", out var leftProp) ? leftProp.GetDouble() : 0;
                    var top = element.TryGetProperty("top", out var topProp) ? topProp.GetDouble() : 0;
                    var right = element.TryGetProperty("right", out var rightProp) ? rightProp.GetDouble() : 0;
                    var bottom = element.TryGetProperty("bottom", out var bottomProp) ? bottomProp.GetDouble() : 0;
                    return new Thickness(left, top, right, bottom);
                }
            }
            else if (value is string thicknessString)
            {
                return Thickness.Parse(thicknessString);
            }
        }

        if (targetType == typeof(CornerRadius))
        {
            if (value is JsonElement element)
            {
                if (element.ValueKind == JsonValueKind.Number) return new CornerRadius(element.GetDouble());

                if (element.ValueKind == JsonValueKind.String)
                {
                    var radiusString = element.GetString() ?? "0";
                    return double.TryParse(radiusString, out var radius)
                        ? new CornerRadius(radius)
                        : new CornerRadius(0);
                }
            }
            else if (value is string radiusString)
            {
                return double.TryParse(radiusString, out var radius)
                    ? new CornerRadius(radius)
                    : new CornerRadius(0);
            }
        }

        if (targetType == typeof(bool) && value is string boolString && bool.TryParse(boolString, out var boolVal))
            return boolVal;

        if (targetType == typeof(double) && value is JsonElement dElement && dElement.ValueKind == JsonValueKind.Number)
            return dElement.GetDouble();
        if (targetType == typeof(double) && value is string doubleString && double.TryParse(doubleString, out var dVal))
            return dVal;

        if (targetType == typeof(FontFamily) && value is string fontFam)
            return new FontFamily(fontFam);

        // Try standard type conversion as fallback
        try
        {
            return Convert.ChangeType(value, targetType);
        }
        catch
        {
            return targetType.IsValueType ? Activator.CreateInstance(targetType) : null;
        }
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Model\PropertyValidationResult.cs
================================================================================

namespace Avalonia.UIStudio.Appearance.Model;

public class PropertyValidationResult
{
    public string PropertyName { get; set; }
    public object? Value { get; set; }
    public object? SuggestedValue { get; set; }
    public string Message { get; set; } = string.Empty;
    public bool IsValid { get; set; } = true;
    public bool IsError { get; set; } = false;
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Model\SerializableSkin.cs
================================================================================

using Avalonia.Media;
using Newtonsoft.Json;

namespace Avalonia.UIStudio.Appearance.Model;

/// <summary>
/// </summary>
public class SerializableSkin
{
    /// <summary>
    ///     Gets or sets the name of the skin.
    /// </summary>
    /// <remarks>
    ///     This property represents the unique identifier or display name of the skin.
    ///     It is a required field and must not be null, empty, or whitespace.
    /// </remarks>
    public string? Name { get; set; } = "";

    /// <summary>
    ///     Gets or sets a description of the skin, providing additional context or details about its purpose or design.
    /// </summary>
    public string Description { get; set; } = "";

    /// <summary>
    ///     Gets or sets the version of the skin.
    /// </summary>
    /// <remarks>
    ///     This property indicates the version of the skin, which can be useful for compatibility checks
    ///     or identifying updates to the skin.
    /// </remarks>
    public string Version { get; set; } = "1.0";

    /// <summary>
    ///     Gets or sets the author of the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="string" /> representing the name of the skin's author.
    /// </value>
    public string Author { get; set; } = "";

    /// <summary>
    ///     Gets or sets the date and time when the skin was created.
    /// </summary>
    /// <value>
    ///     A <see cref="DateTime" /> representing the creation date and time of the skin.
    /// </value>
    public DateTime CreatedDate { get; set; } = DateTime.Now;

    // Colors as hex strings for JSON serialization
    /// <summary>
    /// </summary>
    public string PrimaryColor { get; set; } = "#343B48";

    /// <summary>
    /// </summary>
    public string SecondaryColor { get; set; } = "#3D4654";

    /// <summary>
    /// </summary>
    public string AccentColor { get; set; } = "#3498DB";

    /// <summary>
    /// </summary>
    public string PrimaryBackground { get; set; } = "#2C313D";

    /// <summary>
    /// </summary>
    public string SecondaryBackground { get; set; } = "#464F62";

    /// <summary>
    /// </summary>
    public string PrimaryTextColor { get; set; } = "#FFFFFF";

    /// <summary>
    /// </summary>
    public string SecondaryTextColor { get; set; } = "#CCCCCC";

    /// <summary>
    /// </summary>
    public string BorderColor { get; set; } = "#5D6778";

    /// <summary>
    /// </summary>
    public string ErrorColor { get; set; } = "#E74C3C";

    /// <summary>
    /// </summary>
    public string WarningColor { get; set; } = "#F39C12";

    /// <summary>
    /// </summary>
    public string SuccessColor { get; set; } = "#2ECC71";

    // Typography
    /// <summary>
    /// </summary>
    public string FontFamily { get; set; } = "Segoe UI, San Francisco, Helvetica, Arial, sans-serif";

    /// <summary>
    /// </summary>
    public double FontSizeSmall { get; set; } = 10;

    /// <summary>
    /// </summary>
    public double FontSizeMedium { get; set; } = 12;

    /// <summary>
    /// </summary>
    public double FontSizeLarge { get; set; } = 16;

    /// <summary>
    /// </summary>
    public string FontWeight { get; set; } = "Normal";

    // Layout
    /// <summary>
    /// </summary>
    public double BorderRadius { get; set; } = 4;

    /// <summary>
    /// </summary>
    public SerializableThickness BorderThickness { get; set; } = new() { Left = 1, Top = 1, Right = 1, Bottom = 1 };

    // Advanced typography (optional)
    /// <summary>
    /// </summary>
    public SerializableTypography? AdvancedTypography { get; set; }

    // Inheritance (optional)
    /// <summary>
    /// </summary>
    [JsonIgnore]
    public SerializableSkin? BaseSkin { get; set; }

    /// <summary>
    /// </summary>
    public Dictionary<string, object>? PropertyOverrides { get; set; }

    /// <summary>
    ///     Gets or sets the list of control skin file paths relative to the skin base directory.
    /// </summary>
    public List<string>? ControlThemeUris { get; set; }

    /// <summary>
    ///     Optional named assets like logos or backgrounds.
    /// </summary>
    public List<string>? StyleUris { get; set; }

    public List<string>? AssetUris { get; set; }

    /// <summary>
    ///     Name of the base skin (for inheritance), serialized for persistence.
    /// </summary>
    public string? BaseSkinName { get; set; }

    public string? HeaderFontFamily { get; set; }
    public string? BodyFontFamily { get; set; }
    public string? MonospaceFontFamily { get; set; }

    public double LineHeight { get; set; }
    public double LetterSpacing { get; set; }
    public bool EnableLigatures { get; set; }
}

/// <summary>
/// </summary>
public static class SkinConverterExtensions
{
    /// <summary>
    /// </summary>
    /// <param name="skin"></param>
    /// <returns></returns>
    public static Skin ToSkin(this SerializableSkin skin)
    {
        return new Skin
        {
            Name = skin.Name,
            PrimaryColor = Color.Parse(skin.PrimaryColor),
            SecondaryColor = Color.Parse(skin.SecondaryColor),
            AccentColor = Color.Parse(skin.AccentColor),
            PrimaryBackground = Color.Parse(skin.PrimaryBackground),
            SecondaryBackground = Color.Parse(skin.SecondaryBackground),
            PrimaryTextColor = Color.Parse(skin.PrimaryTextColor),
            SecondaryTextColor = Color.Parse(skin.SecondaryTextColor),
            BorderColor = Color.Parse(skin.BorderColor),
            ErrorColor = Color.Parse(skin.ErrorColor),
            WarningColor = Color.Parse(skin.WarningColor),
            SuccessColor = Color.Parse(skin.SuccessColor),
            FontFamily = new FontFamily(skin.FontFamily),
            FontSizeSmall = skin.FontSizeSmall,
            FontSizeMedium = skin.FontSizeMedium,
            FontSizeLarge = skin.FontSizeLarge,
            FontWeight = Enum.TryParse<FontWeight>(skin.FontWeight, true, out var fw)
                ? fw
                : FontWeight.Normal,
            BorderRadius = skin.BorderRadius,
            BorderThickness = new Thickness(
                skin.BorderThickness.Left,
                skin.BorderThickness.Top,
                skin.BorderThickness.Right,
                skin.BorderThickness.Bottom
            ),
            Typography =
                new TypographyScale
                {
                    DisplayLarge = skin.AdvancedTypography?.DisplayLarge ?? 57,
                    DisplayMedium = skin.AdvancedTypography?.DisplayMedium ?? 45,
                    DisplaySmall = skin.AdvancedTypography?.DisplaySmall ?? 36,
                    HeadlineLarge = skin.AdvancedTypography?.HeadlineLarge ?? 32,
                    HeadlineMedium = skin.AdvancedTypography?.HeadlineMedium ?? 28,
                    HeadlineSmall = skin.AdvancedTypography?.HeadlineSmall ?? 24,
                    TitleLarge = skin.AdvancedTypography?.TitleLarge ?? 22,
                    TitleMedium = skin.AdvancedTypography?.TitleMedium ?? 16,
                    TitleSmall = skin.AdvancedTypography?.TitleSmall ?? 14,
                    LabelLarge = skin.AdvancedTypography?.LabelLarge ?? 14,
                    LabelMedium = skin.AdvancedTypography?.LabelMedium ?? 12,
                    LabelSmall = skin.AdvancedTypography?.LabelSmall ?? 11,
                    BodyLarge = skin.AdvancedTypography?.BodyLarge ?? 16,
                    BodyMedium = skin.AdvancedTypography?.BodyMedium ?? 14,
                    BodySmall = skin.AdvancedTypography?.BodySmall ?? 12
                },
            HeaderFontFamily = new FontFamily(skin.AdvancedTypography?.HeaderFontFamily ?? skin.FontFamily),
            BodyFontFamily = new FontFamily(skin.AdvancedTypography?.BodyFontFamily ?? skin.FontFamily),
            MonospaceFontFamily =
                new FontFamily(skin.AdvancedTypography?.MonospaceFontFamily ??
                               "Consolas, Monaco, 'Courier New', monospace"),
            LineHeight = skin.AdvancedTypography?.LineHeight ?? 1.5,
            LetterSpacing = skin.AdvancedTypography?.LetterSpacing ?? 0,
            EnableLigatures = skin.AdvancedTypography?.EnableLigatures ?? true,
            ControlThemeUris = skin?.ControlThemeUris ?? new List<string>(),
            StyleUris = skin?.StyleUris ?? new List<string>(),
            AssetUris = skin?.AssetUris ?? new List<string>()
        };
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Model\SerializableThickness.cs
================================================================================

namespace Avalonia.UIStudio.Appearance.Model;

/// <summary>
/// </summary>
public class SerializableThickness
{
    /// <summary>
    /// </summary>
    public double Left { get; set; }

    /// <summary>
    /// </summary>
    public double Top { get; set; }

    /// <summary>
    /// </summary>
    public double Right { get; set; }

    /// <summary>
    /// </summary>
    public double Bottom { get; set; }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Model\SerializableTypography.cs
================================================================================

namespace Avalonia.UIStudio.Appearance.Model;

/// <summary>
/// </summary>
public class SerializableTypography
{
    /// <summary>
    /// </summary>
    public double DisplayLarge { get; set; } = 57;

    /// <summary>
    /// </summary>
    public double DisplayMedium { get; set; } = 45;

    /// <summary>
    /// </summary>
    public double DisplaySmall { get; set; } = 36;

    /// <summary>
    /// </summary>
    public double HeadlineLarge { get; set; } = 32;

    /// <summary>
    /// </summary>
    public double HeadlineMedium { get; set; } = 28;

    /// <summary>
    /// </summary>
    public double HeadlineSmall { get; set; } = 24;

    /// <summary>
    /// </summary>
    public double TitleLarge { get; set; } = 22;

    /// <summary>
    /// </summary>
    public double TitleMedium { get; set; } = 16;

    /// <summary>
    /// </summary>
    public double TitleSmall { get; set; } = 14;

    /// <summary>
    /// </summary>
    public double LabelLarge { get; set; } = 14;

    /// <summary>
    /// </summary>
    public double LabelMedium { get; set; } = 12;

    /// <summary>
    /// </summary>
    public double LabelSmall { get; set; } = 11;

    /// <summary>
    /// </summary>
    public double BodyLarge { get; set; } = 16;

    /// <summary>
    /// </summary>
    public double BodyMedium { get; set; } = 14;

    /// <summary>
    /// </summary>
    public double BodySmall { get; set; } = 12;

    /// <summary>
    /// </summary>
    /// <summary>
    /// </summary>
    public string? HeaderFontFamily { get; set; } = "Segoe UI, San Francisco, Helvetica, Arial, sans-serif";

    /// <summary>
    /// </summary>
    public string? BodyFontFamily { get; set; } = "Segoe UI, San Francisco, Helvetica, Arial, sans-serif";

    /// <summary>
    /// </summary>
    public string? MonospaceFontFamily { get; set; } = "Consolas, Monaco, 'Courier New', monospace";

    /// <summary>
    /// </summary>
    public double LineHeight { get; set; } = 1.5;

    /// <summary>
    /// </summary>
    public double LetterSpacing { get; set; } = 0;

    /// <summary>
    /// </summary>
    public bool EnableLigatures { get; set; } = true;
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Model\Skin.cs
================================================================================

using Avalonia.Media;
using Avalonia.UIStudio.Appearance.Extensions;

namespace Avalonia.UIStudio.Appearance.Model;

/// <summary>
///     Represents a customizable skin for an Avalonia application, defining colors, fonts, and other visual properties.
/// </summary>
/// <remarks>
///     The <see cref="Skin" /> class provides a set of properties to define the appearance of an application,
///     including primary and secondary colors, background colors, text colors, font settings, and additional UI
///     properties.
///     It also includes functionality to convert colors to brushes and a default constructor for initializing a dark skin.
/// </remarks>
public class Skin
{
    /// <summary>
    /// </summary>
    public Skin()
    {
        // Set default values for Dark skin
        PrimaryColor = Color.Parse("#343B48"); // GunMetal Dark
        SecondaryColor = Color.Parse("#3D4654"); // GunMetal Medium
        AccentColor = Color.Parse("#3498DB"); // Accent Blue
        PrimaryBackground = Color.Parse("#2C313D"); // Dark background
        SecondaryBackground = Color.Parse("#464F62"); // GunMetal Light
        PrimaryTextColor = Color.Parse("#FFFFFF");
        SecondaryTextColor = Color.Parse("#CCCCCC");
        FontFamily = new FontFamily("Segoe UI, San Francisco, Helvetica, Arial, sans-serif");
        FontSizeSmall = 10;
        FontSizeMedium = 12;
        FontSizeLarge = 16;
        FontWeight = FontWeight.Normal;
        BorderColor = Color.Parse("#5D6778");
        BorderThickness = new Thickness(1);
        BorderRadius = 4;
        ErrorColor = Color.Parse("#E74C3C");
        WarningColor = Color.Parse("#F39C12");
        SuccessColor = Color.Parse("#2ECC71");
        HeaderFontFamily = FontFamily;
        BodyFontFamily = FontFamily;
        MonospaceFontFamily = new FontFamily("Consolas, Monaco, 'Courier New', monospace");
        BaseSkin = null;
        Name = "Dark";
    }

    public string Description { get; set; }

    // Basic colors
    /// <summary>
    ///     Gets or sets the primary color of the skin.
    /// </summary>
    /// <remarks>
    ///     This color is typically used as the main color for UI elements and serves as a foundation
    ///     for the overall skin design. The default value for the dark skin is GunMetal Dark (#343B48).
    /// </remarks>
    public Color PrimaryColor { get; set; }

    /// <summary>
    ///     Gets or sets the secondary color used in the skin.
    /// </summary>
    /// <remarks>
    ///     This color is typically used for medium-tone elements within the skin.
    ///     The default value for the dark skin is <c>#3D4654</c> (GunMetal Medium).
    /// </remarks>
    public Color SecondaryColor { get; set; }

    /// <summary>
    ///     Gets or sets the accent color of the skin.
    /// </summary>
    /// <remarks>
    ///     The accent color is used to highlight key elements in the user interface,
    ///     providing a visually distinct color that complements the primary and secondary colors.
    /// </remarks>
    public Color AccentColor { get; set; }

    // Backgrounds
    /// <summary>
    ///     Gets or sets the primary background color of the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="Color" /> representing the primary background color.
    /// </value>
    public Color PrimaryBackground { get; set; }

    /// <summary>
    ///     Gets or sets the secondary background color of the skin.
    /// </summary>
    /// <remarks>
    ///     This property defines the secondary background color used in the skin.
    ///     It is typically a lighter shade of the primary background color to provide contrast and visual hierarchy.
    /// </remarks>
    public Color SecondaryBackground { get; set; }

    /// <summary>
    ///     Gets or sets the primary text color used in the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="Color" /> representing the primary text color.
    ///     The default value is white (<c>#FFFFFF</c>).
    /// </value>
    public Color PrimaryTextColor { get; set; }

    /// <summary>
    ///     Gets or sets the color used for secondary text elements in the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="Color" /> representing the secondary text color. The default value is a light gray color (#CCCCCC).
    /// </value>
    public Color SecondaryTextColor { get; set; }

    // Font properties
    /// <summary>
    ///     Gets or sets the font family used for text rendering in the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="FontFamily" /> representing the font family. The default value is "Segoe UI, San Francisco, Helvetica,
    ///     Arial, sans-serif".
    /// </value>
    public FontFamily FontFamily { get; set; }

    /// <summary>
    ///     Gets or sets the font size for small text elements in the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="double" /> representing the font size for small text elements. The default value is 10.
    /// </value>
    public double FontSizeSmall { get; set; }

    /// <summary>
    ///     Gets or sets the medium font size used in the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="double" /> representing the medium font size.
    /// </value>
    public double FontSizeMedium { get; set; }

    /// <summary>
    ///     Gets or sets the font size for large text elements in the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="double" /> representing the font size for large text elements.
    ///     The default value is 16.
    /// </value>
    public double FontSizeLarge { get; set; }

    /// <summary>
    ///     Gets or sets the font weight used in the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="FontWeight" /> value that specifies the weight of the font.
    ///     The default value is <see cref="FontWeight.Normal" />.
    /// </value>
    public FontWeight FontWeight { get; set; }

    /// <summary>
    ///     Gets or sets the color of the border in the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="Color" /> representing the border color.
    /// </value>
    public Color BorderColor { get; set; }

    /// <summary>
    ///     Gets or sets the thickness of the border for the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="Thickness" /> structure that specifies the thickness of the border.
    /// </value>
    public Thickness BorderThickness { get; set; }

    /// <summary>
    ///     Gets or sets the border radius applied to UI elements in the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="double" /> representing the radius of the border corners, in device-independent units (DIPs).
    /// </value>
    public double BorderRadius { get; set; }

    // Additional UI properties
    /// <summary>
    ///     Gets or sets the color used to represent error states in the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="Color" /> representing the error color. The default value is typically a shade of red.
    /// </value>
    public Color ErrorColor { get; set; }

    /// <summary>
    ///     Gets or sets the color used to represent warnings in the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="Color" /> representing the warning color. The default value is "#F39C12".
    /// </value>
    public Color WarningColor { get; set; }

    /// <summary>
    ///     Gets or sets the color used to represent success states in the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="Color" /> representing the success color.
    /// </value>
    public Color SuccessColor { get; set; }

    // Name of the skin
    /// <summary>
    ///     Gets or sets the name of the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="string" /> representing the name of the skin.
    ///     The default value is "Dark".
    /// </value>
    public string? Name { get; set; }

    // Constructor with default values
    // URIs to ControlTheme resources mapped by control type or key
    /// <summary>
    ///     Gets or sets the dictionary of control theme resource URIs used in the skin.
    /// </summary>
    /// <remarks>
    ///     Keys typically represent control types or identifiers, and values are the associated resource URIs (e.g., avares
    ///     URIs).
    /// </remarks>
    public List<string> ControlThemeUris { get; set; } = new();

    // URIs to general Style resources mapped by key
    /// <summary>
    ///     Gets or sets the dictionary of style resource URIs used in the skin.
    /// </summary>
    /// <remarks>
    ///     These styles can define visual behavior for multiple controls or layout elements.
    /// </remarks>
    public List<string> StyleUris { get; set; } = new();

    // Extended typography information such as font scaling and weight map
    /// <summary>
    ///     Gets or sets the typography scale for the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="TypographyScale" /> object used to define consistent typography sizing and scaling for various text
    ///     styles.
    /// </value>
    public TypographyScale? Typography { get; set; } = new();

    // Additional font families for specific text roles
    /// <summary>
    ///     Gets or sets the font family used for headers.
    /// </summary>
    public FontFamily? HeaderFontFamily { get; set; }

    /// <summary>
    ///     Gets or sets the font family used for body text.
    /// </summary>
    public FontFamily? BodyFontFamily { get; set; }

    /// <summary>
    ///     Gets or sets the font family used for monospace content (e.g., code blocks).
    /// </summary>
    public FontFamily? MonospaceFontFamily { get; set; }

    // Line height and spacing for typographic elements
    /// <summary>
    ///     Gets or sets the line height multiplier used in text layout.
    /// </summary>
    /// <remarks>
    ///     This is typically a multiplier on the font size to determine the vertical spacing between lines.
    /// </remarks>
    public double LineHeight { get; set; } = 1.5;

    /// <summary>
    ///     Gets or sets the letter spacing used in the skin.
    /// </summary>
    /// <value>
    ///     A <see cref="double" /> representing additional space between letters in DIPs. Default is 0.
    /// </value>
    public double LetterSpacing { get; set; }

    /// <summary>
    ///     Gets or sets a value indicating whether ligatures are enabled in text rendering.
    /// </summary>
    /// <value>
    ///     <c>true</c> to enable ligatures; otherwise, <c>false</c>.
    /// </value>
    public bool EnableLigatures { get; set; } = true;

    /// <summary>
    ///     Dictionary of named asset URIs (images, SVGs, etc.).
    /// </summary>
    public List<string> AssetUris { get; set; } = new();

    /// <summary>
    /// </summary>
    public InheritableSkin? BaseSkin { get; set; }

    /// <summary>
    /// </summary>
    /// <param name="baseSkin"></param>
    public void InheritFrom(Skin baseSkin)
    {
        PrimaryColor = PrimaryColor == default ? baseSkin.PrimaryColor : PrimaryColor;
        SecondaryColor = SecondaryColor == default ? baseSkin.SecondaryColor : SecondaryColor;
        AccentColor = AccentColor == default ? baseSkin.AccentColor : AccentColor;
        PrimaryBackground = PrimaryBackground == default ? baseSkin.PrimaryBackground : PrimaryBackground;
        SecondaryBackground = SecondaryBackground == default ? baseSkin.SecondaryBackground : SecondaryBackground;
        PrimaryTextColor = PrimaryTextColor == default ? baseSkin.PrimaryTextColor : PrimaryTextColor;
        SecondaryTextColor = SecondaryTextColor == default ? baseSkin.SecondaryTextColor : SecondaryTextColor;
        BorderColor = BorderColor == default ? baseSkin.BorderColor : BorderColor;
        ErrorColor = ErrorColor == default ? baseSkin.ErrorColor : ErrorColor;
        WarningColor = WarningColor == default ? baseSkin.WarningColor : WarningColor;
        SuccessColor = SuccessColor == default ? baseSkin.SuccessColor : SuccessColor;

        FontFamily ??= baseSkin.FontFamily;
        HeaderFontFamily ??= baseSkin.HeaderFontFamily;
        BodyFontFamily ??= baseSkin.BodyFontFamily;
        MonospaceFontFamily ??= baseSkin.MonospaceFontFamily;

        FontSizeSmall = FontSizeSmall == 0 ? baseSkin.FontSizeSmall : FontSizeSmall;
        FontSizeMedium = FontSizeMedium == 0 ? baseSkin.FontSizeMedium : FontSizeMedium;
        FontSizeLarge = FontSizeLarge == 0 ? baseSkin.FontSizeLarge : FontSizeLarge;
        FontWeight = FontWeight == default ? baseSkin.FontWeight : FontWeight;

        BorderRadius = BorderRadius == 0 ? baseSkin.BorderRadius : BorderRadius;
        BorderThickness = BorderThickness == default ? baseSkin.BorderThickness : BorderThickness;

        LineHeight = LineHeight == 0 ? baseSkin.LineHeight : LineHeight;
        LetterSpacing = LetterSpacing == 0 ? baseSkin.LetterSpacing : LetterSpacing;
        // Typography scale
        Typography ??= new TypographyScale();
        if (baseSkin.Typography != null) Typography.ApplyFallbacksFrom(baseSkin.Typography);

        // Merge control theme URIs and styles (child overrides take precedence)
    }

    // Creates a brush from a color
    /// <summary>
    ///     Converts the specified <see cref="Color" /> to a <see cref="SolidColorBrush" />.
    /// </summary>
    /// <param name="color">The <see cref="Color" /> to convert.</param>
    /// <returns>A <see cref="SolidColorBrush" /> representing the specified color.</returns>
    public static SolidColorBrush ToBrush(Color color)
    {
        return new SolidColorBrush(color);
    }
}

public static class SkinExtensions
{
    public static SerializableSkin ToSerializable(this Skin skin, string? description = null, string? author = null)
    {
        return new SerializableSkin
        {
            Name = skin.Name ?? "Unnamed Skin",
            Description = description ?? skin.Description ?? "",
            Author = author ?? "",

            PrimaryColor = skin.PrimaryColor.ToString(),
            SecondaryColor = skin.SecondaryColor.ToString(),
            AccentColor = skin.AccentColor.ToString(),
            PrimaryBackground = skin.PrimaryBackground.ToString(),
            SecondaryBackground = skin.SecondaryBackground.ToString(),
            PrimaryTextColor = skin.PrimaryTextColor.ToString(),
            SecondaryTextColor = skin.SecondaryTextColor.ToString(),
            BorderColor = skin.BorderColor.ToString(),
            ErrorColor = skin.ErrorColor.ToString(),
            WarningColor = skin.WarningColor.ToString(),
            SuccessColor = skin.SuccessColor.ToString(),

            FontFamily = skin.FontFamily.ToString(),
            FontSizeSmall = skin.FontSizeSmall,
            FontSizeMedium = skin.FontSizeMedium,
            FontSizeLarge = skin.FontSizeLarge,
            FontWeight = skin.FontWeight.ToString(),

            HeaderFontFamily = skin.HeaderFontFamily?.ToString(),
            BodyFontFamily = skin.BodyFontFamily?.ToString(),
            MonospaceFontFamily = skin.MonospaceFontFamily?.ToString(),

            LineHeight = skin.LineHeight,
            LetterSpacing = skin.LetterSpacing,
            EnableLigatures = skin.EnableLigatures,

            BorderRadius = skin.BorderRadius,
            BorderThickness = new SerializableThickness
            {
                Left = skin.BorderThickness.Left,
                Top = skin.BorderThickness.Top,
                Right = skin.BorderThickness.Right,
                Bottom = skin.BorderThickness.Bottom
            },

            AdvancedTypography = skin.Typography.ToSerializable(skin),
            StyleUris = skin.StyleUris,
            ControlThemeUris = skin.ControlThemeUris,
            AssetUris = skin.AssetUris,

            BaseSkin = skin.BaseSkin != null
                ? new SerializableSkin
                {
                    Name = skin.BaseSkin.Name
                }
                : null
        };
    }

}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Model\SkinImportResult.cs
================================================================================

namespace Avalonia.UIStudio.Appearance.Model;

/// <summary>
/// </summary>
public class SkinImportResult
{
    /// <summary>
    /// </summary>
    public Skin? Skin { get; set; }

    /// <summary>
    /// </summary>
    public bool Success { get; set; }

    /// <summary>
    /// </summary>
    public string? ErrorMessage { get; set; }

    /// <summary>
    /// </summary>
    public List<string> Warnings { get; set; } = new();
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Model\SkinSummaryInfo.cs
================================================================================

using Avalonia.Media;

namespace Avalonia.UIStudio.Appearance.Model;

/// <summary>
///     Represents information about a skin, including its name, description, and a preview color.
/// </summary>
/// <remarks>
///     This class is used to encapsulate the details of a skin, which can be displayed in the UI
///     or used for skin management purposes within the application.
/// </remarks>
public class SkinSummaryInfo
{
    /// <summary>
    ///     Gets or sets the name of the skin.
    /// </summary>
    /// <remarks>
    ///     The name uniquely identifies the skin and is used for selection and application purposes.
    /// </remarks>
    public string Name { get; set; } = "";

    /// <summary>
    ///     Gets or sets the description of the skin.
    /// </summary>
    /// <remarks>
    ///     This property provides a textual description of the skin, which can be displayed in the user interface
    ///     to give users more context about the skin's purpose or appearance.
    /// </remarks>
    public string Description { get; set; } = "";

    /// <summary>
    ///     Gets or sets the brush used to represent the preview color of the skin.
    /// </summary>
    /// <remarks>
    ///     This property is typically used to display a visual representation of the skin's accent color
    ///     in the user interface, such as in skin selection controls.
    /// </remarks>
    public IBrush PreviewColor { get; set; } = Brushes.Transparent;
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Model\SkinValidationMessage.cs
================================================================================

namespace Avalonia.UIStudio.Appearance.Model;

public class SkinValidationMessage
{
    public bool IsError { get; set; }
    public string Message { get; set; } = string.Empty;

    /// <summary>
    ///     Names of properties involved in this validation message.
    /// </summary>
    public List<string> InvolvedProperties { get; set; } = new();

    /// <summary>
    ///     Suggested values for involved properties (if applicable).
    ///     Example:
    ///     { "PrimaryTextColor" => Color }
    ///     { "FontSizeSmall" => 12.0 }
    ///     { "Name" => "My Skin Name" }
    /// </summary>
    public Dictionary<string, object?> SuggestedValues { get; set; } = new();
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Model\SkinValidationResult.cs
================================================================================

namespace Avalonia.UIStudio.Appearance.Model;

/// <summary>
///     Represents the result of skin validation.
/// </summary>
public class SkinValidationResult
{
    public bool IsValid { get; set; } = true;

    public List<SkinValidationMessage> ValidationMessages { get; set; } = new();

    public List<string> Errors => ValidationMessages
        .Where(v => v.IsError)
        .Select(v => v.Message)
        .ToList();

    public List<string> Warnings => ValidationMessages
        .Where(v => !v.IsError)
        .Select(v => v.Message)
        .ToList();
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Model\TypographyScale.cs
================================================================================

// Skin/TypographySystem.cs

namespace Avalonia.UIStudio.Appearance.Model;

/// <summary>
///     Defines typography scale and settings for skins.
/// </summary>
public class TypographyScale
{
    // Display sizes (largest)
    /// <summary>
    ///     Gets or sets the size of the largest display typography.
    /// </summary>
    /// <value>
    ///     A <see cref="double" /> representing the size of the largest display typography.
    ///     The default value is 57.
    /// </value>
    public double DisplayLarge { get; set; } = 57;

    /// <summary>
    ///     Gets or sets the medium display typography size.
    /// </summary>
    /// <value>
    ///     The size of the medium display typography, typically used for prominent text elements.
    ///     The default value is 45.
    /// </value>
    public double DisplayMedium { get; set; } = 45;

    /// <summary>
    ///     Gets or sets the size of the "Display Small" typography, typically used for smaller display text.
    /// </summary>
    /// <value>
    ///     A <see cref="double" /> representing the size of the "Display Small" typography. The default value is 36.
    /// </value>
    public double DisplaySmall { get; set; } = 36;

    // Headline sizes
    /// <summary>
    ///     Gets or sets the font size for large headlines in the typography scale.
    /// </summary>
    /// <value>
    ///     A <see cref="double" /> representing the font size for large headlines.
    ///     The default value is 32.
    /// </value>
    public double HeadlineLarge { get; set; } = 32;

    /// <summary>
    ///     Gets or sets the font size for medium-sized headlines in the typography scale.
    /// </summary>
    /// <value>
    ///     The font size for medium-sized headlines, typically used for emphasizing content
    ///     that is less prominent than large headlines but more significant than small headlines.
    ///     The default value is 28.
    /// </value>
    public double HeadlineMedium { get; set; } = 28;

    /// <summary>
    ///     Gets or sets the font size for small headline text in the typography scale.
    /// </summary>
    /// <value>
    ///     A <see cref="double" /> representing the font size for small headline text.
    ///     The default value is 24.
    /// </value>
    public double HeadlineSmall { get; set; } = 24;

    // Title sizes
    /// <summary>
    ///     Gets or sets the font size for large titles in the typography scale.
    /// </summary>
    /// <value>
    ///     The font size for large titles, typically used for prominent headings or titles.
    ///     The default value is 22.
    /// </value>
    public double TitleLarge { get; set; } = 22;

    /// <summary>
    ///     Gets or sets the font size for medium-sized titles in the typography scale.
    /// </summary>
    /// <value>
    ///     The font size for medium-sized titles, typically used for medium emphasis text elements.
    ///     The default value is 16.
    /// </value>
    public double TitleMedium { get; set; } = 16;

    /// <summary>
    ///     Gets or sets the font size for small titles in the typography scale.
    /// </summary>
    /// <value>
    ///     The font size for small titles, typically used for less prominent headings or titles.
    ///     The default value is 14.
    /// </value>
    public double TitleSmall { get; set; } = 14;

    // Label sizes
    /// <summary>
    ///     Gets or sets the font size for large labels in the typography scale.
    /// </summary>
    /// <value>
    ///     The size of the font for large labels, typically used for prominent labeling.
    ///     The default value is 14.
    /// </value>
    public double LabelLarge { get; set; } = 14;

    /// <summary>
    ///     Gets or sets the font size for medium-sized labels in the typography scale.
    /// </summary>
    /// <value>
    ///     The font size for medium-sized labels. The default value is 12.
    /// </value>
    public double LabelMedium { get; set; } = 12;

    /// <summary>
    ///     Gets or sets the font size for small labels in the typography scale.
    /// </summary>
    /// <value>
    ///     The font size, in device-independent units (DIPs), for small labels. The default value is 11.
    /// </value>
    public double LabelSmall { get; set; } = 11;

    // Body sizes
    /// <summary>
    ///     Gets or sets the font size for large body text.
    /// </summary>
    /// <value>
    ///     The font size for large body text, typically used for primary content areas.
    ///     Default value is 16.
    /// </value>
    public double BodyLarge { get; set; } = 16;

    /// <summary>
    ///     Gets or sets the font size for medium body text in the typography scale.
    /// </summary>
    /// <value>
    ///     The font size, in device-independent units (DIPs), for medium body text.
    ///     The default value is 14.
    /// </value>
    public double BodyMedium { get; set; } = 14;

    /// <summary>
    ///     Gets or sets the font size for small body text.
    /// </summary>
    /// <value>
    ///     The font size for small body text, typically used for less prominent content.
    /// </value>
    public double BodySmall { get; set; } = 12;

    /// <summary>
    ///     Applies a scale factor to all typography sizes.
    /// </summary>
    public void ApplyScale(double scaleFactor)
    {
        DisplayLarge *= scaleFactor;
        DisplayMedium *= scaleFactor;
        DisplaySmall *= scaleFactor;
        HeadlineLarge *= scaleFactor;
        HeadlineMedium *= scaleFactor;
        HeadlineSmall *= scaleFactor;
        TitleLarge *= scaleFactor;
        TitleMedium *= scaleFactor;
        TitleSmall *= scaleFactor;
        LabelLarge *= scaleFactor;
        LabelMedium *= scaleFactor;
        LabelSmall *= scaleFactor;
        BodyLarge *= scaleFactor;
        BodyMedium *= scaleFactor;
        BodySmall *= scaleFactor;
    }

    // Add these methods to TypographyScale.cs
    /// <summary>
    /// </summary>
    /// <returns></returns>
    public TypographyScale Clone()
    {
        return new TypographyScale
        {
            DisplayLarge = DisplayLarge,
            DisplayMedium = DisplayMedium,
            DisplaySmall = DisplaySmall,
            HeadlineLarge = HeadlineLarge,
            HeadlineMedium = HeadlineMedium,
            HeadlineSmall = HeadlineSmall,
            TitleLarge = TitleLarge,
            TitleMedium = TitleMedium,
            TitleSmall = TitleSmall,
            LabelLarge = LabelLarge,
            LabelMedium = LabelMedium,
            LabelSmall = LabelSmall,
            BodyLarge = BodyLarge,
            BodyMedium = BodyMedium,
            BodySmall = BodySmall
        };
    }

    /// <summary>
    /// </summary>
    public void Reset()
    {
        DisplayLarge = 57;
        DisplayMedium = 45;
        DisplaySmall = 36;
        HeadlineLarge = 32;
        HeadlineMedium = 28;
        HeadlineSmall = 24;
        TitleLarge = 22;
        TitleMedium = 16;
        TitleSmall = 14;
        LabelLarge = 14;
        LabelMedium = 12;
        LabelSmall = 11;
        BodyLarge = 16;
        BodyMedium = 14;
        BodySmall = 12;
    }

    /// <summary>
    /// </summary>
    /// <returns></returns>
    public bool ValidateScale()
    {
        return DisplayLarge > DisplayMedium &&
               DisplayMedium > DisplaySmall &&
               HeadlineLarge > HeadlineMedium &&
               HeadlineMedium > HeadlineSmall &&
               TitleLarge > TitleMedium &&
               TitleMedium > TitleSmall &&
               BodyLarge > BodyMedium &&
               BodyMedium > BodySmall;
    }

    public void ApplyFallbacksFrom(TypographyScale fallback)
    {
        DisplayLarge = DisplayLarge == 0 ? fallback.DisplayLarge : DisplayLarge;
        DisplayMedium = DisplayMedium == 0 ? fallback.DisplayMedium : DisplayMedium;
        DisplaySmall = DisplaySmall == 0 ? fallback.DisplaySmall : DisplaySmall;
        HeadlineLarge = HeadlineLarge == 0 ? fallback.HeadlineLarge : HeadlineLarge;
        HeadlineMedium = HeadlineMedium == 0 ? fallback.HeadlineMedium : HeadlineMedium;
        HeadlineSmall = HeadlineSmall == 0 ? fallback.HeadlineSmall : HeadlineSmall;
        TitleLarge = TitleLarge == 0 ? fallback.TitleLarge : TitleLarge;
        TitleMedium = TitleMedium == 0 ? fallback.TitleMedium : TitleMedium;
        TitleSmall = TitleSmall == 0 ? fallback.TitleSmall : TitleSmall;
        LabelLarge = LabelLarge == 0 ? fallback.LabelLarge : LabelLarge;
        LabelMedium = LabelMedium == 0 ? fallback.LabelMedium : LabelMedium;
        LabelSmall = LabelSmall == 0 ? fallback.LabelSmall : LabelSmall;
        BodyLarge = BodyLarge == 0 ? fallback.BodyLarge : BodyLarge;
        BodyMedium = BodyMedium == 0 ? fallback.BodyMedium : BodyMedium;
        BodySmall = BodySmall == 0 ? fallback.BodySmall : BodySmall;
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Model\ValidatedProperty.cs
================================================================================

using ReactiveUI;

namespace Avalonia.UIStudio.Appearance.Model;

public class ValidatedProperty
{
    public SkinValidationMessage OriginalMessage { get; set; }
    public string Name { get; set; }
    public bool IsValid { get; set; }
    public object Value { get; set; }

    public object SuggestedValue { get; set; }

    public string Message { get; set; }
}

public class ValidatableProperty<T> : ReactiveObject
{
    private T _value;

    public ValidatableProperty(string propertyName, T initialValue)
    {
        ValidationResult.PropertyName = propertyName;
        _value = initialValue;
        ValidationResult.Value = initialValue;
    }

    public PropertyValidationResult ValidationResult { get; } = new();

    public T Value
    {
        get => _value;
        set
        {
            this.RaiseAndSetIfChanged(ref _value, value);
            ValidationResult.Value = value;
        }
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Selectors\PropertyEditorTemplateSelector.cs
================================================================================

using Avalonia.Controls;
using Avalonia.Controls.Templates;
using Avalonia.Metadata;
using Avalonia.UIStudio.Appearance.ViewModels;

namespace Avalonia.UIStudio.Appearance.Selectors;

public class PropertyEditorTemplateSelector : IDataTemplate
{
    [Content] public Dictionary<Type, IDataTemplate> Templates { get; } = new();

    public bool Match(object? data)
    {
        return data is PropertyViewModel;
    }

    public Control Build(object? param)
    {
        if (param is PropertyViewModel propertyVm)
        {
            var vmType = propertyVm.GetType();
            if (Templates.TryGetValue(vmType, out var template)) return template.Build(param);
        }

        // fallback
        return new TextBlock { Text = "Unknown Property Type" };
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Services\SkinImportExportService.cs
================================================================================

// Skin/SkinImportExportService.cs

using System.Text.Json;
using System.Text.Json.Serialization;
using Avalonia.Media;
using Avalonia.UIStudio.Appearance.Interfaces;
using Avalonia.UIStudio.Appearance.Model;

namespace Avalonia.UIStudio.Appearance.Services;

/// <summary>
///     Handles skin import and export operations.
/// </summary>
public class SkinImportExportService : ISkinImportExportService
{
    private static readonly JsonSerializerOptions JsonOptions = new()
    {
        WriteIndented = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
    };

    /// <summary>
    ///     Exports a skin to a JSON file.
    /// </summary>
    public async Task<bool> ExportSkinAsync(Skin skin, string filePath, string? description = null,
        string? author = null)
    {
        try
        {
            var serializableSkin = skin.ToSerializable(description, author);
            var json = JsonSerializer.Serialize(serializableSkin, JsonOptions);

            await File.WriteAllTextAsync(filePath, json);
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error exporting skin: {ex.Message}");
            return false;
        }
    }

    /// <summary>
    ///     Exports an advanced skin with typography to a JSON file.
    /// </summary>
    public async Task<bool> ExportAdvancedSkinAsync(Skin skin, string filePath, string? description = null,
        string? author = null)
    {
        try
        {
            var serializableSkin = skin.ToSerializable(description, author);

            // Add advanced typography
            if (skin.Typography != null)
                serializableSkin.AdvancedTypography = new SerializableTypography
                {
                    DisplayLarge = skin.Typography.DisplayLarge,
                    DisplayMedium = skin.Typography.DisplayMedium,
                    DisplaySmall = skin.Typography.DisplaySmall,
                    HeadlineLarge = skin.Typography.HeadlineLarge,
                    HeadlineMedium = skin.Typography.HeadlineMedium,
                    HeadlineSmall = skin.Typography.HeadlineSmall,
                    TitleLarge = skin.Typography.TitleLarge,
                    TitleMedium = skin.Typography.TitleMedium,
                    TitleSmall = skin.Typography.TitleSmall,
                    LabelLarge = skin.Typography.LabelLarge,
                    LabelMedium = skin.Typography.LabelMedium,
                    LabelSmall = skin.Typography.LabelSmall,
                    BodyLarge = skin.Typography.BodyLarge,
                    BodyMedium = skin.Typography.BodyMedium,
                    BodySmall = skin.Typography.BodySmall,
                    HeaderFontFamily = skin.HeaderFontFamily?.ToString(),
                    BodyFontFamily = skin.BodyFontFamily?.ToString(),
                    MonospaceFontFamily = skin.MonospaceFontFamily?.ToString(),
                    LineHeight = skin.LineHeight,
                    LetterSpacing = skin.LetterSpacing,
                    EnableLigatures = skin.EnableLigatures
                };

            var json = JsonSerializer.Serialize(serializableSkin, JsonOptions);
            await File.WriteAllTextAsync(filePath, json);
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error exporting advanced skin: {ex.Message}");
            return false;
        }
    }

    /// <summary>
    ///     Exports an inheritable skin to a JSON file.
    /// </summary>
    public async Task<bool> ExportInheritableSkinAsync(InheritableSkin skin, string filePath,
        string? description = null, string? author = null)
    {
        try
        {
            var serializableSkin = skin.ToSerializable(description, author);

            // Add inheritance information
            serializableSkin.BaseSkinName = skin.BaseSkinName;
            serializableSkin.PropertyOverrides = skin.PropertyOverrides;

            var json = JsonSerializer.Serialize(serializableSkin, JsonOptions);
            await File.WriteAllTextAsync(filePath, json);
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error exporting inheritable skin: {ex.Message}");
            return false;
        }
    }

    /// <summary>
    ///     Imports a skin from a JSON file.
    /// </summary>
    public async Task<SkinImportResult> ImportSkinAsync(string filePath)
    {
        var result = new SkinImportResult();

        try
        {
            if (!File.Exists(filePath))
            {
                result.ErrorMessage = $"Skin file does not exist: {filePath}";
                return result;
            }

            var json = await File.ReadAllTextAsync(filePath);
            var serializableSkin = JsonSerializer.Deserialize<SerializableSkin>(json, JsonOptions);

            if (serializableSkin == null)
            {
                result.ErrorMessage = "Invalid skin file format";
                return result;
            }

            // Validate before converting
            var validation = await ValidateSkinFileAsync(filePath);
            if (!validation.IsValid)
            {
                result.ErrorMessage = $"Skin validation failed: {string.Join(", ", validation.Errors)}";
                result.Warnings.AddRange(validation.Warnings);
                return result;
            }

            result.Skin = ConvertFromSerializable(serializableSkin);
            result.Success = true;
        }
        catch (JsonException ex)
        {
            result.ErrorMessage = $"JSON parsing error: {ex.Message}";
        }
        catch (Exception ex)
        {
            result.ErrorMessage = $"Unexpected error importing skin: {ex.Message}";
        }

        return result;
    }

    /// <summary>
    ///     Imports an advanced skin from a JSON file.
    /// </summary>
    public async Task<Skin?> ImportAdvancedSkinAsync(string filePath)
    {
        try
        {
            var json = await File.ReadAllTextAsync(filePath);
            var serializableSkin = JsonSerializer.Deserialize<SerializableSkin>(json, JsonOptions);

            if (serializableSkin == null) return null;

            var baseSkin = ConvertFromSerializable(serializableSkin);


            // Apply advanced typography if present
            if (serializableSkin.AdvancedTypography != null)
            {
                var typography = serializableSkin.AdvancedTypography;

                baseSkin.Typography = new TypographyScale
                {
                    DisplayLarge = typography.DisplayLarge,
                    DisplayMedium = typography.DisplayMedium,
                    DisplaySmall = typography.DisplaySmall,
                    HeadlineLarge = typography.HeadlineLarge,
                    HeadlineMedium = typography.HeadlineMedium,
                    HeadlineSmall = typography.HeadlineSmall,
                    TitleLarge = typography.TitleLarge,
                    TitleMedium = typography.TitleMedium,
                    TitleSmall = typography.TitleSmall,
                    LabelLarge = typography.LabelLarge,
                    LabelMedium = typography.LabelMedium,
                    LabelSmall = typography.LabelSmall,
                    BodyLarge = typography.BodyLarge,
                    BodyMedium = typography.BodyMedium,
                    BodySmall = typography.BodySmall
                };

                if (typography.HeaderFontFamily != null)
                    baseSkin.HeaderFontFamily = new FontFamily(typography.HeaderFontFamily);
                if (typography.BodyFontFamily != null)
                    baseSkin.BodyFontFamily = new FontFamily(typography.BodyFontFamily);
                if (typography.MonospaceFontFamily != null)
                    baseSkin.MonospaceFontFamily = new FontFamily(typography.MonospaceFontFamily);
                baseSkin.LineHeight = typography.LineHeight;
                baseSkin.LetterSpacing = typography.LetterSpacing;
                baseSkin.EnableLigatures = typography.EnableLigatures;
            }

            return baseSkin;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error importing advanced skin: {ex.Message}");
            return null;
        }
    }

    /// <summary>
    ///     Imports an inheritable skin from a JSON file.
    /// </summary>
    public async Task<InheritableSkin?> ImportInheritableSkinAsync(string filePath)
    {
        try
        {
            var json = await File.ReadAllTextAsync(filePath);
            var serializableSkin = JsonSerializer.Deserialize<SerializableSkin>(json, JsonOptions);

            if (serializableSkin == null) return null;

            var baseSkin = ConvertFromSerializable(serializableSkin);
            var inheritableSkin = new InheritableSkin();

            // Copy all properties from base skin
            CopyPropertiesToInheritable(inheritableSkin, baseSkin);

            // Set inheritance properties
            inheritableSkin.BaseSkinName = serializableSkin.BaseSkinName;
            inheritableSkin.PropertyOverrides = serializableSkin.PropertyOverrides ?? new Dictionary<string, object>();

            return inheritableSkin;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error importing inheritable skin: {ex.Message}");
            return null;
        }
    }

    /// <summary>
    ///     Validates a skin file before importing.
    /// </summary>
    public async Task<SkinValidationResult> ValidateSkinFileAsync(string filePath)
    {
        var result = new SkinValidationResult();

        try
        {
            if (!File.Exists(filePath))
            {
                result.ValidationMessages.Add(new SkinValidationMessage
                {
                    IsError = true,
                    Message = "Skin file does not exist",
                    InvolvedProperties = new List<string>(),
                    SuggestedValues = new Dictionary<string, object?>()
                });
                result.IsValid = false;
                return result;
            }

            var json = await File.ReadAllTextAsync(filePath);
            var serializableSkin = JsonSerializer.Deserialize<SerializableSkin>(json, JsonOptions);

            if (serializableSkin == null)
            {
                result.ValidationMessages.Add(new SkinValidationMessage
                {
                    IsError = true,
                    Message = "Invalid JSON format",
                    InvolvedProperties = new List<string>(),
                    SuggestedValues = new Dictionary<string, object?>()
                });
                return result;
            }

            // Validate required fields
            if (string.IsNullOrWhiteSpace(serializableSkin.Name))
                result.ValidationMessages.Add(new SkinValidationMessage
                {
                    IsError = true,
                    Message = "Skin name is required",
                    InvolvedProperties = new List<string>(),
                    SuggestedValues = new Dictionary<string, object?>()
                });

            // Try to convert to validate color formats
            try
            {
                var skin = ConvertFromSerializable(serializableSkin);
                var validator = new SkinValidator();
                var validationResult = validator.ValidateSkin(skin);

                result.Errors.AddRange(validationResult.Errors);
                result.Warnings.AddRange(validationResult.Warnings);
                result.IsValid = validationResult.IsValid && result.Errors.Count == 0;
            }
            catch (Exception ex)
            {
                result.ValidationMessages.Add(new SkinValidationMessage
                {
                    IsError = true,
                    Message = $"Invalid skin data: {ex.Message}",
                    InvolvedProperties = new List<string>(),
                    SuggestedValues = new Dictionary<string, object?>()
                });
            }
        }
        catch (JsonException)
        {
            result.IsValid = false;
            result.ValidationMessages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = "Invalid JSON format",
                InvolvedProperties = new List<string>(),
                SuggestedValues = new Dictionary<string, object?>()
            });
        }
        catch (Exception ex)
        {
            result.IsValid = false;
            result.ValidationMessages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = $"Error reading skin file: {ex.Message}",
                InvolvedProperties = new List<string>(),
                SuggestedValues = new Dictionary<string, object?>()
            });
        }

        return result;
    }

    /// <summary>
    ///     Exports multiple skins to a skin pack file.
    /// </summary>
    public async Task<bool> ExportSkinPackAsync(Dictionary<string, Skin> skins, string filePath, string packName,
        string? description = null)
    {
        try
        {
            var skinPack = new
            {
                Name = packName,
                Description = description,
                Version = "1.0",
                CreatedDate = DateTime.Now,
                Skins = skins.Select(kvp => kvp.Value.ToSerializable(description)).ToArray()
            };

            var json = JsonSerializer.Serialize(skinPack, JsonOptions);
            await File.WriteAllTextAsync(filePath, json);
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error exporting skin pack: {ex.Message}");
            return false;
        }
    }


    private static FontFamily ParseFontFamily(string fontFamily)
    {
        if (string.IsNullOrWhiteSpace(fontFamily))
            return FontFamily.Default;

        // Prevent problematic generic names being interpreted as relative URIs
        var safeFamilies = new[] { "serif", "sans-serif", "monospace" };
        foreach (var fam in safeFamilies)
            if (fontFamily.Contains(fam))
                return FontFamily.Default;

        if (safeFamilies.Contains(fontFamily.Trim().ToLowerInvariant())) return FontFamily.Default;


        return new FontFamily(fontFamily);
    }


    private static Skin ConvertFromSerializable(SerializableSkin serializableSkin)
    {
        var fontWeight = Enum.TryParse<FontWeight>(serializableSkin.FontWeight, out var weight)
            ? weight
            : FontWeight.Normal;

        return new Skin
        {
            Name = serializableSkin.Name,
            PrimaryColor = Color.Parse(serializableSkin.PrimaryColor),
            SecondaryColor = Color.Parse(serializableSkin.SecondaryColor),
            AccentColor = Color.Parse(serializableSkin.AccentColor),
            PrimaryBackground = Color.Parse(serializableSkin.PrimaryBackground),
            SecondaryBackground = Color.Parse(serializableSkin.SecondaryBackground),
            PrimaryTextColor = Color.Parse(serializableSkin.PrimaryTextColor),
            SecondaryTextColor = Color.Parse(serializableSkin.SecondaryTextColor),
            BorderColor = Color.Parse(serializableSkin.BorderColor),
            ErrorColor = Color.Parse(serializableSkin.ErrorColor),
            WarningColor = Color.Parse(serializableSkin.WarningColor),
            SuccessColor = Color.Parse(serializableSkin.SuccessColor),
            FontFamily = ParseFontFamily(serializableSkin.FontFamily),
            FontSizeSmall = serializableSkin.FontSizeSmall,
            FontSizeMedium = serializableSkin.FontSizeMedium,
            FontSizeLarge = serializableSkin.FontSizeLarge,
            FontWeight = fontWeight,
            BorderRadius = serializableSkin.BorderRadius,
            BorderThickness = new Thickness(
                serializableSkin.BorderThickness.Left,
                serializableSkin.BorderThickness.Top,
                serializableSkin.BorderThickness.Right,
                serializableSkin.BorderThickness.Bottom
            )
        };
    }

    private static void CopyPropertiesToInheritable(InheritableSkin target, Skin source)
    {
        target.PrimaryColor = source.PrimaryColor;
        target.SecondaryColor = source.SecondaryColor;
        target.AccentColor = source.AccentColor;
        target.PrimaryBackground = source.PrimaryBackground;
        target.SecondaryBackground = source.SecondaryBackground;
        target.PrimaryTextColor = source.PrimaryTextColor;
        target.SecondaryTextColor = source.SecondaryTextColor;
        target.FontFamily = source.FontFamily;
        target.FontSizeSmall = source.FontSizeSmall;
        target.FontSizeMedium = source.FontSizeMedium;
        target.FontSizeLarge = source.FontSizeLarge;
        target.FontWeight = source.FontWeight;
        target.BorderColor = source.BorderColor;
        target.BorderThickness = source.BorderThickness;
        target.BorderRadius = source.BorderRadius;
        target.ErrorColor = source.ErrorColor;
        target.WarningColor = source.WarningColor;
        target.SuccessColor = source.SuccessColor;
        target.Name = source.Name;
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Services\SkinInheritanceManager.cs
================================================================================

using Avalonia.UIStudio.Appearance.Interfaces;
using Avalonia.UIStudio.Appearance.Model;

namespace Avalonia.UIStudio.Appearance.Services;

/// <summary>
///     Manages skin inheritance and variant creation with dependency injection support.
/// </summary>
public class SkinInheritanceManager
{
    private readonly Dictionary<string, InheritableSkin?> _inheritableSkins = new();
    private readonly Dictionary<string, Skin> _resolvedCache = new();
    private readonly ISkinManager _skinManager;

    /// <summary>
    ///     Initializes a new instance of the SkinInheritanceManager class.
    /// </summary>
    /// <param name="skinManager">The skin manager to use for resolving base skins.</param>
    /// <exception cref="ArgumentNullException">Thrown when skinManager is null.</exception>
    public SkinInheritanceManager(ISkinManager skinManager)
    {
        _skinManager = skinManager ?? throw new ArgumentNullException(nameof(skinManager));
    }

    /// <summary>
    ///     Registers an inheritable skin.
    /// </summary>
    public void RegisterInheritableSkin(string? name, InheritableSkin? skin)
    {
        if (string.IsNullOrEmpty(name))
            throw new ArgumentException("Skin name cannot be null or empty", nameof(name));
        if (skin == null)
            throw new ArgumentNullException(nameof(skin));

        skin.Name = name;
        _inheritableSkins[name] = skin;
        _resolvedCache.Remove(name); // Clear cache
    }

    /// <summary>
    ///     Gets a resolved skin with inheritance applied.
    /// </summary>
    public Skin? GetResolvedSkin(string? name)
    {
        if (string.IsNullOrEmpty(name))
            return null;

        if (_resolvedCache.TryGetValue(name, out var cached)) return cached;

        if (!_inheritableSkins.TryGetValue(name, out var inheritableSkin)) return null;

        if (inheritableSkin != null)
        {
            var baseSkin = GetBaseSkin(inheritableSkin);
            var resolved = inheritableSkin.CreateResolvedSkin(baseSkin);

            _resolvedCache[name] = resolved;
            return resolved;
        }

        return null;
    }

    private Skin? GetBaseSkin(InheritableSkin skin)
    {
        if (string.IsNullOrEmpty(skin.BaseSkinName)) return null;

        // Handle recursive inheritance
        if (_inheritableSkins.TryGetValue(skin.BaseSkinName, out var baseInheritable))
            return GetResolvedSkin(skin.BaseSkinName);

        // Fall back to skin manager (now uses injected dependency)
        return _skinManager.GetSkin(skin.BaseSkinName);
    }

    /// <summary>
    ///     Creates a skin variant by overriding specific properties.
    /// </summary>
    public InheritableSkin? CreateVariant(string? baseName, string? variantName, Dictionary<string, object>? overrides)
    {
        if (string.IsNullOrEmpty(baseName))
            throw new ArgumentException("Base skin name cannot be null or empty", nameof(baseName));
        if (string.IsNullOrEmpty(variantName))
            throw new ArgumentException("Variant skin name cannot be null or empty", nameof(variantName));
        if (overrides == null)
            throw new ArgumentNullException(nameof(overrides));

        var variant = new InheritableSkin
        {
            Name = variantName,
            BaseSkinName = baseName,
            PropertyOverrides = overrides
        };

        RegisterInheritableSkin(variantName, variant);
        return variant;
    }

    /// <summary>
    ///     Clears the resolved skin cache.
    /// </summary>
    public void ClearCache()
    {
        _resolvedCache.Clear();
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Services\SkinLoaderService.cs
================================================================================

using System.Text.Json;
using Avalonia.Platform;
using Avalonia.UIStudio.Appearance.Model;

namespace Avalonia.UIStudio.Appearance.Services;

/// <summary>
///     Defines a service for loading skins in an Avalonia application.
/// </summary>
/// <remarks>
///     This interface provides methods to load skins skins from a specified directory.
///     Implementations of this interface are responsible for parsing and managing skin-related resources.
/// </remarks>
public interface ISkinLoaderService
{
    /// <summary>
    ///     Loads a collection of skins from the specified root directory.
    /// </summary>
    /// <param name="skinsRoot">
    ///     The root directory containing skin definitions.
    /// </param>
    /// <returns>
    ///     A list of <see cref="Skin" /> objects representing the loaded skins.
    /// </returns>
    List<Skin> LoadSkins(string skinsRoot);
}

/// <summary>
///     Provides functionality to load and manage skins for the Avalonia application.
/// </summary>
/// <remarks>
///     This service is responsible for loading skins configurations and resources from a specified directory structure.
///     It processes skins definitions, controlthemes, and styles, making them available for use within the application.
/// </remarks>
public class SkinLoaderService : ISkinLoaderService
{

    /// <summary>
    ///     Loads a collection of <see cref="Skin" /> objects from the specified root directory.
    /// </summary>
    /// <returns>
    ///     A list of <see cref="Skin" /> objects representing the loaded skins.
    /// </returns>
    /// <remarks>
    ///     This method scans the specified directory for subdirectories containing skin definitions.
    ///     Each skin is expected to have a "skin.json" file and optionally "ControlThemes" and "Styles" directories
    ///     containing .axaml files. The method parses these resources and constructs <see cref="Skin" /> objects
    ///     with appropriate URIs for controlthemes and styles.
    /// </remarks>
    public List<Skin> LoadSkins(string skinsRoot = "avares://Avalonia.UIStudio.Appearance/Skins/")
    {
        var jsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        };

        var skins = new List<Skin>();

        var baseUri = new Uri(skinsRoot);

        // Build skin names list from avares assets
        var skinNames = new List<string>();

        try
        {
            var skinJsonAssets = AssetLoader.GetAssets(new Uri(skinsRoot), null)
                .Where(uri => uri.ToString().EndsWith("/skin.json", StringComparison.OrdinalIgnoreCase))
                .ToList();

            // Extract skin names from avares uris
            foreach (var skinJsonUri in skinJsonAssets)
            {
                var parts = skinJsonUri.ToString().Split('/');
                if (parts.Length >= 2)
                {
                    var skinName = parts[^2]; // the folder name before /skin.json
                    if (!string.IsNullOrWhiteSpace(skinName) && !skinNames.Contains(skinName))
                        skinNames.Add(skinName);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to enumerate skin folders: {ex.Message}");
        }

        // Now load each skin, UserOverrides first
        foreach (var skinName in skinNames)
        {
            var loadedFromOverride = false;

            var userOverridePath = $"./Skins/UserOverrides/{skinName}/skin.json";
            if (File.Exists(userOverridePath))
                try
                {
                    var json = File.ReadAllText(userOverridePath);
                    var serializableSkin = JsonSerializer.Deserialize<SerializableSkin>(json, jsonOptions);
                    if (serializableSkin != null)
                    {
                        var skin = serializableSkin.ToSkin();
                        skins.Add(skin);
                        loadedFromOverride = true;
                        Console.WriteLine($"Loaded skin '{skinName}' from UserOverrides.");
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Failed to load user override skin '{skinName}': {ex.Message}");
                }

            if (!loadedFromOverride)
                try
                {
                    var avaresPath = $"{skinsRoot}{skinName}/skin.json";
                    var avaresUri = new Uri(avaresPath);

                    using var stream = AssetLoader.Open(avaresUri);
                    using var reader = new StreamReader(stream);
                    var json = reader.ReadToEnd();

                    var serializableSkin = JsonSerializer.Deserialize<SerializableSkin>(json, jsonOptions);
                    if (serializableSkin is null) continue;

                    var skin = serializableSkin.ToSkin();
                    skins.Add(skin);
                    Console.WriteLine($"Loaded built-in skin '{skinName}'.");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Failed to load built-in skin '{skinName}': {ex.Message}");
                }
        }

        // Inheritance resolution
        foreach (var skin in skins)
            if (skin.BaseSkin is { } baseskin)
                if (!string.IsNullOrWhiteSpace(baseskin.BaseSkinName))
                {
                    var baseSkin = skins.FirstOrDefault(s =>
                        s.Name != null && s.Name.Equals(baseskin.BaseSkinName, StringComparison.OrdinalIgnoreCase));
                    if (baseSkin != null) skin.InheritFrom(baseSkin);
                }

        return skins;
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Services\SkinManager.cs
================================================================================

using Avalonia.Controls;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Markup.Xaml.Styling;
using Avalonia.Media;
using Avalonia.Styling;
using Avalonia.UIStudio.Appearance.Interfaces;
using Avalonia.UIStudio.Appearance.Model;

namespace Avalonia.UIStudio.Appearance.Services;

/// <summary>
///     Manages the skins for an Avalonia application, providing functionality to register, retrieve, and apply skins.
/// </summary>
/// <remarks>
///     This class serves as a singleton instance to manage the available skins and the currently applied skin.
///     It provides methods to register new skins, retrieve existing skins by name, and apply a specific skin.
///     Additionally, it raises events when the skin is changed, allowing other components to react to skin updates.
/// </remarks>
public class SkinManager : ISkinManager
{
    private readonly IApplication _application;
    private readonly List<IResourceProvider> _appliedControlThemeDictionaries = new();
    private readonly List<IStyle> _appliedControlThemes = new();
    private readonly Dictionary<string, Skin?> _availableSkins = new();
    private readonly ISkinLoaderService _skinLoaderService;
    private readonly IStylesCollection _styles;


    /// <summary>
    ///     Initializes a new instance of the <see cref="SkinManager" /> class with dependency injection.
    /// </summary>
    /// <param name="skinLoaderService">The skin loader service for loading available skins.</param>
    /// <param name="application">The application abstraction for accessing resources and styles.</param>
    public SkinManager(ISkinLoaderService skinLoaderService, IApplication application)
    {
        _skinLoaderService = skinLoaderService ?? throw new ArgumentNullException(nameof(skinLoaderService));
        _application = application ?? throw new ArgumentNullException(nameof(application));
        _styles = application.AppStyles ?? throw new InvalidOperationException("Application.AppStyles is null.");

        RegisterDefaultSkins();
    }

    /// <summary>
    ///     Gets the singleton instance of the <see cref="SkinManager" /> class,
    ///     which is responsible for managing skins in an Avalonia application.
    /// </summary>
    /// <value>
    ///     The singleton instance of <see cref="SkinManager" />.
    /// </value>
    /// <remarks>
    ///     This property ensures that only one instance of <see cref="SkinManager" /> exists throughout the application.
    ///     It provides centralized access to skin management functionality, including registering, retrieving, and applying
    ///     skins.
    /// </remarks>
    public static SkinManager? Instance { get; set; }

    /// <summary>
    ///     Gets the currently applied <see cref="Skin" /> in the application.
    /// </summary>
    /// <value>
    ///     The <see cref="Skin" /> instance representing the current skin, or <c>null</c> if no skin is applied.
    /// </value>
    /// <remarks>
    ///     Use this property to retrieve or monitor the active skin in the application.
    ///     Changes to the current skin can be handled through the <see cref="SkinChanged" /> event.
    /// </remarks>
    public Skin? CurrentSkin { get; private set; }

    /// <summary>
    ///     Event that is raised when the skin is changed.
    /// </summary>
    public event EventHandler? SkinChanged;

    /// <summary>
    ///     Registers a new skin with the specified name.
    /// </summary>
    /// <param name="name">The name of the skin to register. This value must not be <c>null</c>.</param>
    /// <param name="skin">The <see cref="Skin" /> instance to register. This value must not be <c>null</c>.</param>
    /// <remarks>
    ///     If both <paramref name="name" /> and <paramref name="skin" /> are not <c>null</c>, the skin is added to the
    ///     collection of available skins.
    /// </remarks>
    public void RegisterSkin(string? name, Skin? skin)
    {
        if (skin != null && name != null)
        {
            skin.Name = name;
            _availableSkins[name] = skin;
        }
    }

    /// <summary>
    ///     Retrieves a <see cref="Skin" /> instance by its name.
    /// </summary>
    /// <param name="name">The name of the skin to retrieve. If <c>null</c>, the current skin is returned.</param>
    /// <returns>
    ///     The <see cref="Skin" /> instance associated with the specified name,
    ///     or the current skin if the name is not found or is <c>null</c>.
    /// </returns>
    public Skin? GetSkin(string? name)
    {
        if (name != null && _availableSkins.TryGetValue(name, out var skin))
            return skin;
        return CurrentSkin;
    }

    /// <summary>
    ///     Retrieves the names of all available skins registered in the <see cref="SkinManager" />.
    /// </summary>
    /// <returns>A list of strings representing the names of the available skins.</returns>
    public List<string> GetAvailableSkinNames()
    {
        return _availableSkins.Keys.ToList();
    }

    /// <summary>
    ///     Applies a skin to the application by its name.
    /// </summary>
    /// <param name="skinName">
    ///     The name of the skin to apply. If the skin with the specified name is not found,
    ///     an error message will be logged.
    /// </param>
    /// <remarks>
    ///     If the specified skin exists, it will be applied, and the selected skin will be saved.
    ///     If the skin does not exist or an error occurs during the application, an appropriate
    ///     message will be logged.
    /// </remarks>
    /// <exception cref="Exception">
    ///     Logs any exception that occurs while applying the skin.
    /// </exception>
    public void ApplySkin(string? skinName)
    {
        try
        {
            if (skinName != null && _availableSkins.TryGetValue(skinName, out var skin))
            {
                ApplySkin(skin);
                SaveSelectedSkin(skinName);
            }
            else
            {
                Console.WriteLine($"Skin not found: {skinName}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error applying skin {skinName}: {ex.Message}");
        }
    }

    /// <summary>
    ///     Applies the specified skin to the application, updating resources and triggering the <see cref="SkinChanged" />
    ///     event.
    /// </summary>
    /// <param name="skin">The <see cref="Skin" /> to be applied. If <c>null</c>, a default skin will be applied.</param>
    /// <remarks>
    ///     This method updates the application's resources and typography settings based on the provided skin.
    ///     If an exception occurs during the application of the skin, it will be logged to the console.
    /// </remarks>
    public void ApplySkin(Skin? skin)
    {
        if (skin == null)
            skin = new Skin();

        CurrentSkin = skin;

        try
        {
            UpdateResources();
            UpdateTypographyResources(skin);
            SkinChanged?.Invoke(this, EventArgs.Empty);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error applying custom skin: {ex.Message}");
        }
    }

    /// <summary>
    ///     Saves the name of the currently selected skin to the application settings.
    /// </summary>
    /// <param name="skinName">
    ///     The name of the skin to save. If <c>null</c>, no action is performed.
    /// </param>
    /// <remarks>
    ///     This method updates the skin name in the application settings and persists the changes.
    ///     It is typically called after applying a new skin to ensure the selected skin is remembered
    ///     across application sessions.
    /// </remarks>
    public void SaveSelectedSkin(string? skinName)
    {
        if (skinName != null)
        {
            AppSettings.Instance.Skin = skinName;
            AppSettings.Instance.Save();
        }
    }

    public string GetSkinFilePath(Skin skin)
    {
        // You may want to make this more configurable
        return $"./Skins/{skin.Name}/skin.json";
    }

    public void ReloadSkins()
    {
        _availableSkins.Clear();
        RegisterDefaultSkins();
        LoadSavedSkin();
    }

    /// <summary>
    ///     Loads the previously saved skin and applies it to the application.
    /// </summary>
    /// <remarks>
    ///     This method retrieves the saved skin name from the application settings and applies it if it exists
    ///     in the list of available skins. If no saved skin is found or the saved skin is not available,
    ///     no changes are made to the current skin.
    /// </remarks>
    /// <example>
    ///     Example usage:
    ///     <code>
    /// var skinManager = SkinManager.Instance;
    /// skinManager.LoadSavedSkin();
    /// </code>
    /// </example>
    public void LoadSavedSkin()
    {
        var skinName = AppSettings.Instance.Skin;
        if (!string.IsNullOrEmpty(skinName) && _availableSkins.ContainsKey(skinName))
            ApplySkin(skinName);
    }


    private void RegisterDefaultSkins()
    {
        var skinsPath = "avares://Avalonia.UIStudio.Appearance/Skins/";
        var skins = _skinLoaderService.LoadSkins(skinsPath);
        foreach (var skin in skins) RegisterSkin(skin.Name, skin);
    }

    private void UpdateTypographyResources(Skin skin)
    {
        var resources = _application.Resources;
        if (resources == null) return;

        try
        {
            // Typography scale
            if (skin.Typography != null)
            {
                resources["DisplayLargeFontSize"] = skin.Typography.DisplayLarge;
                resources["DisplayMediumFontSize"] = skin.Typography.DisplayMedium;
                resources["DisplaySmallFontSize"] = skin.Typography.DisplaySmall;
                resources["HeadlineLargeFontSize"] = skin.Typography.HeadlineLarge;
                resources["HeadlineMediumFontSize"] = skin.Typography.HeadlineMedium;
                resources["HeadlineSmallFontSize"] = skin.Typography.HeadlineSmall;
                resources["TitleLargeFontSize"] = skin.Typography.TitleLarge;
                resources["TitleMediumFontSize"] = skin.Typography.TitleMedium;
                resources["TitleSmallFontSize"] = skin.Typography.TitleSmall;
                resources["LabelLargeFontSize"] = skin.Typography.LabelLarge;
                resources["LabelMediumFontSize"] = skin.Typography.LabelMedium;
                resources["LabelSmallFontSize"] = skin.Typography.LabelSmall;
                resources["BodyLargeFontSize"] = skin.Typography.BodyLarge;
                resources["BodyMediumFontSize"] = skin.Typography.BodyMedium;
                resources["BodySmallFontSize"] = skin.Typography.BodySmall;
            }

            // Font families
            resources["HeaderFontFamily"] = skin.HeaderFontFamily;
            resources["BodyFontFamily"] = skin.BodyFontFamily;
            resources["MonospaceFontFamily"] = skin.MonospaceFontFamily;

            // Text properties
            resources["DefaultLineHeight"] = skin.LineHeight;
            resources["DefaultLetterSpacing"] = skin.LetterSpacing;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating typography resources: {ex.Message}");
        }
    }

    private void UpdateResources()
    {
        if (CurrentSkin == null)
            return;

        var resources = _application.Resources;
        if (resources == null)
            return;

        UpdateBrush(resources, "PrimaryColorBrush", CurrentSkin.PrimaryColor);
        UpdateBrush(resources, "SecondaryColorBrush", CurrentSkin.SecondaryColor);
        UpdateBrush(resources, "AccentBlueBrush", CurrentSkin.AccentColor);
        UpdateBrush(resources, "GunMetalDarkBrush", CurrentSkin.PrimaryColor);
        UpdateBrush(resources, "GunMetalMediumBrush", CurrentSkin.SecondaryColor);
        UpdateBrush(resources, "GunMetalLightBrush", CurrentSkin.SecondaryBackground);
        UpdateBrush(resources, "BackgroundBrush", CurrentSkin.PrimaryBackground);
        UpdateBrush(resources, "BackgroundLightBrush", CurrentSkin.SecondaryBackground);
        var dark = new Color(CurrentSkin.PrimaryBackground.A, (byte)(CurrentSkin.PrimaryBackground.R * 0.8),
            (byte)(CurrentSkin.PrimaryBackground.G * 0.8), (byte)(CurrentSkin.PrimaryBackground.B * 0.8));
        UpdateBrush(resources, "BackgroundDarkBrush", dark);
        UpdateBrush(resources, "TextPrimaryBrush", CurrentSkin.PrimaryTextColor);
        UpdateBrush(resources, "TextSecondaryBrush", CurrentSkin.SecondaryTextColor);
        UpdateBrush(resources, "BorderBrush", CurrentSkin.BorderColor);
        UpdateBrush(resources, "ErrorBrush", CurrentSkin.ErrorColor);
        UpdateBrush(resources, "WarningBrush", CurrentSkin.WarningColor);
        UpdateBrush(resources, "SuccessBrush", CurrentSkin.SuccessColor);

        resources["DefaultFontFamily"] = CurrentSkin.FontFamily;
        resources["FontSizeSmall"] = CurrentSkin.FontSizeSmall;
        resources["FontSizeMedium"] = CurrentSkin.FontSizeMedium;
        resources["FontSizeLarge"] = CurrentSkin.FontSizeLarge;
        resources["DefaultFontWeight"] = CurrentSkin.FontWeight;
        resources["BorderThickness"] = CurrentSkin.BorderThickness;
        resources["CornerRadius"] = new CornerRadius(CurrentSkin.BorderRadius);

        ApplyControlThemes(CurrentSkin);
        ForceVisualUpdate();
    }

    private void ApplyControlThemes(Skin skin)
    {
        // Remove previously applied styles from Styles collection
        foreach (var style in _appliedControlThemes)
            if (_styles.Contains(style))
                _styles.Remove(style);

        _appliedControlThemes.Clear();

        // Clear previously applied control themes from MergedDictionaries
        foreach (var controlThemeDict in _appliedControlThemeDictionaries)
            _application.Resources.MergedDictionaries.Remove(controlThemeDict);

        _appliedControlThemeDictionaries.Clear();

        // ✅ Add new ControlTheme dictionaries
        foreach (var kvp in skin.ControlThemeUris)
        {
            var baseUri = new Uri($"avares://Avalonia.UIStudio.Appearance/Skins/{skin.Name}/",
                UriKind.RelativeOrAbsolute);

            // Create a ResourceInclude instance, specifying the base URI and the source file
            var myResourceInclude = new ResourceInclude(baseUri)
            {
                Source = new Uri(kvp, UriKind.Relative)
            };
            try
            {
                _application.Resources.MergedDictionaries.Add(myResourceInclude);
                _appliedControlThemeDictionaries.Add(myResourceInclude);
            }
            catch (Exception ex)
            {
                var test = ex.Message;
            }
        }


        // ✅ Add new styles (normal StyleInclude)
        foreach (var kvp in skin.StyleUris)
            if (kvp != null)
            {
                var style = new StyleInclude(new Uri("avares://Avalonia.UIStudio.Appearance/"))
                {
                    Source = new Uri(kvp)
                };

                _styles.Add(style);
                _appliedControlThemes.Add(style);
            }
    }


    private void UpdateBrush(IResourceDictionary dict, string key, Color color)
    {
        if (dict.TryGetValue(key, out var existingBrush) && existingBrush is SolidColorBrush brush)
            brush.Color = color;
        else
            dict[key] = new SolidColorBrush(color);
    }

    private void ForceVisualUpdate()
    {
        if (_application.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
            foreach (var window in desktop.Windows)
            {
                window.InvalidateVisual();
                InvalidateRecursive(window);
            }
    }

    private void InvalidateRecursive(Control control)
    {
        control.InvalidateVisual();

        if (control is Panel panel)
            foreach (var child in panel.Children)
                InvalidateRecursive(child);
        else if (control is ContentControl cc && cc.Content is Control c)
            InvalidateRecursive(c);
        else if (control is ItemsControl ic && ic.ItemsPanelRoot is Control ip)
            InvalidateRecursive(ip);
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Services\SkinValidator.cs
================================================================================

using Avalonia.Media;
using Avalonia.UIStudio.Appearance.Interfaces;
using Avalonia.UIStudio.Appearance.Model;
using Avalonia.UIStudio.Appearance.Services.ValidationRules;

namespace Avalonia.UIStudio.Appearance.Services;

/// <summary>
///     Validates skin configurations and provides error recovery.
/// </summary>
public class SkinValidator
{
    private readonly List<ISkinValidationRule> _validationRules;

    /// <summary>
    ///     Initializes a new instance of the <see cref="SkinValidator" /> class.
    /// </summary>
    /// <remarks>
    ///     This constructor sets up the default validation rules for skin validation,
    ///     including checks for color contrast, font size, border consistency, naming conventions,
    ///     and accessibility compliance.
    /// </remarks>
    public SkinValidator()
    {
        _validationRules = new List<ISkinValidationRule>
        {
            new ColorContrastValidationRule(),
            new FontSizeValidationRule(),
            new BorderValidationRule(),
            new NameValidationRule(),
            new AccessibilityValidationRule()
        };
    }

    /// <summary>
    ///     Validates a skin and returns validation results.
    /// </summary>
    // Update the ValidateSkin method in SkinValidator class
    public SkinValidationResult ValidateSkin(Skin skin)
    {
        var result = new SkinValidationResult();

        foreach (var rule in _validationRules)
        {
            var ruleMessages = rule.Validate(skin);
            result.ValidationMessages.AddRange(ruleMessages);
        }

        result.IsValid = result.ValidationMessages.All(v => !v.IsError);

        return result;
    }

    /// <summary>
    ///     Attempts to fix validation errors automatically.
    /// </summary>
    public Skin AutoFixSkin(Skin skin)
    {
        var cloneSkin = CloneSkin(skin);

        // Fix null or invalid name
        if (string.IsNullOrWhiteSpace(cloneSkin.Name)) cloneSkin.Name = "Custom Skin";

        // Ensure font sizes are within reasonable bounds
        cloneSkin.FontSizeSmall = Math.Max(8, Math.Min(20, cloneSkin.FontSizeSmall));
        cloneSkin.FontSizeMedium = Math.Max(10, Math.Min(24, cloneSkin.FontSizeMedium));
        cloneSkin.FontSizeLarge = Math.Max(12, Math.Min(32, cloneSkin.FontSizeLarge));

        // Ensure border radius is positive
        cloneSkin.BorderRadius = Math.Max(0, cloneSkin.BorderRadius);

        // Fix color contrast issues
        cloneSkin = FixColorContrast(cloneSkin);

        return cloneSkin;
    }

    private Skin CloneSkin(Skin original)
    {
        return new Skin
        {
            Name = original.Name,
            PrimaryColor = original.PrimaryColor,
            SecondaryColor = original.SecondaryColor,
            AccentColor = original.AccentColor,
            PrimaryBackground = original.PrimaryBackground,
            SecondaryBackground = original.SecondaryBackground,
            PrimaryTextColor = original.PrimaryTextColor,
            SecondaryTextColor = original.SecondaryTextColor,
            FontFamily = original.FontFamily,
            FontSizeSmall = original.FontSizeSmall,
            FontSizeMedium = original.FontSizeMedium,
            FontSizeLarge = original.FontSizeLarge,
            FontWeight = original.FontWeight,
            BorderColor = original.BorderColor,
            BorderThickness = original.BorderThickness,
            BorderRadius = original.BorderRadius,
            ErrorColor = original.ErrorColor,
            WarningColor = original.WarningColor,
            SuccessColor = original.SuccessColor
        };
    }

    private Skin FixColorContrast(Skin skin)
    {
        // Calculate contrast ratio and adjust if needed
        var primaryContrastRatio = CalculateContrastRatio(skin.PrimaryTextColor, skin.PrimaryBackground);

        if (primaryContrastRatio < 4.5) // WCAG AA minimum
            // Adjust text color for better contrast
            skin.PrimaryTextColor = AdjustColorForContrast(skin.PrimaryTextColor, skin.PrimaryBackground, 4.5);

        var secondaryContrastRatio = CalculateContrastRatio(skin.SecondaryTextColor, skin.SecondaryBackground);

        if (secondaryContrastRatio < 3.0) // More lenient for secondary text
            skin.SecondaryTextColor =
                AdjustColorForContrast(skin.SecondaryTextColor, skin.SecondaryBackground, 3.0);

        return skin;
    }

    /// <summary>
    /// </summary>
    /// <param name="foreground"></param>
    /// <param name="background"></param>
    /// <returns></returns>
    public double CalculateContrastRatio(Color foreground, Color background)
    {
        try
        {
            var fgLuminance = GetRelativeLuminance(foreground);
            var bgLuminance = GetRelativeLuminance(background);

            var lighter = Math.Max(fgLuminance, bgLuminance);
            var darker = Math.Min(fgLuminance, bgLuminance);

            return (lighter + 0.05) / (darker + 0.05);
        }
        catch (Exception)
        {
            // Return a safe default contrast ratio
            return 1.0;
        }
    }

    private double GetRelativeLuminance(Color color)
    {
        var r = GetLuminanceComponent(color.R / 255.0);
        var g = GetLuminanceComponent(color.G / 255.0);
        var b = GetLuminanceComponent(color.B / 255.0);

        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    }

    private double GetLuminanceComponent(double component)
    {
        return component <= 0.03928
            ? component / 12.92
            : Math.Pow((component + 0.055) / 1.055, 2.4);
    }

    public Color AdjustColorForContrast(Color foreground, Color background, double targetRatio)
    {
        var bgLuminance = GetRelativeLuminance(background);
        var isDarkBackground = bgLuminance < 0.5;

        // For dark backgrounds, make text lighter; for light backgrounds, make text darker
        var step = isDarkBackground ? 10 : -10;
        var adjustedColor = foreground;

        for (var i = 0; i < 25; i++) // Limit iterations to prevent infinite loop
        {
            var ratio = CalculateContrastRatio(adjustedColor, background);
            if (ratio >= targetRatio) break;

            adjustedColor = Color.FromRgb(
                (byte)Math.Max(0, Math.Min(255, adjustedColor.R + step)),
                (byte)Math.Max(0, Math.Min(255, adjustedColor.G + step)),
                (byte)Math.Max(0, Math.Min(255, adjustedColor.B + step))
            );
        }

        return adjustedColor;
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Services\TypeHelpers.cs
================================================================================

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Avalonia.UIStudio.Appearance.Services
{
    public static class TypeHelpers
    {


        public static bool IsListOfStrings(Type type)
        {
            if (type == typeof(string))
                return false;

            if (typeof(IEnumerable<string>).IsAssignableFrom(type))
                return true;

            if (type.IsGenericType &&
                type.GetGenericTypeDefinition() == typeof(List<>) &&
                type.GetGenericArguments()[0] == typeof(string))
                return true;

            if (type.IsArray && type.GetElementType() == typeof(string))
                return true;

            return false;
        }

        public static bool IsListOfObjects(Type type)
        {
            if (type == typeof(string))
                return false;

            if (typeof(IEnumerable).IsAssignableFrom(type) &&
                type != typeof(string))
            {
                var elementType = GetElementType(type);
                return elementType != null &&
                       !elementType.IsPrimitive &&
                       elementType != typeof(string) &&
                       !elementType.IsEnum;
            }

            return false;
        }

        public static Type? GetElementType(Type type)
        {
            if (type.IsArray)
                return type.GetElementType();

            if (type.IsGenericType && typeof(IEnumerable<>).IsAssignableFrom(type.GetGenericTypeDefinition()))
                return type.GetGenericArguments()[0];

            foreach (var iface in type.GetInterfaces())
            {
                if (iface.IsGenericType && iface.GetGenericTypeDefinition() == typeof(IEnumerable<>))
                    return iface.GetGenericArguments()[0];
            }

            return null;
        }
    }
}

================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\ViewModels\EditableControlTheme.cs
================================================================================

using System.Collections.ObjectModel;
using ReactiveUI;

namespace Avalonia.UIStudio.Appearance.ViewModels;

public class EditableControlTheme : ReactiveObject
{
    // The type of control this theme is for (Button, TextBox, etc.)
    public string ControlType { get; set; } = string.Empty;

    // The base template this control theme is based on (Template1, Template2, etc.)
    public string? BaseTemplateName { get; set; }

    // Editable Setters - Property name → Value (object supports Color, Thickness, etc.)
    public ObservableCollection<EditableSetter> Setters { get; } = new();

    // Convenience: get or set a value by property name
    public void SetOrUpdateSetter(string propertyName, object value)
    {
        var existing = Setters.FirstOrDefault(s => s.PropertyName == propertyName);
        if (existing != null)
            existing.Value = value;
        else
            Setters.Add(new EditableSetter
            {
                PropertyName = propertyName,
                Value = value
            });
    }

    public object? GetSetterValue(string propertyName)
    {
        return Setters.FirstOrDefault(s => s.PropertyName == propertyName)?.Value;
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\ViewModels\EditableSetter.cs
================================================================================

using ReactiveUI;

namespace Avalonia.UIStudio.Appearance.ViewModels;

public class EditableSetter : ReactiveObject
{
    private object? _value;
    public string PropertyName { get; set; } = string.Empty;

    public object? Value
    {
        get => _value;
        set => this.RaiseAndSetIfChanged(ref _value, value);
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\ViewModels\EditableSkinViewModel.cs
================================================================================

using System.Collections.ObjectModel;
using Avalonia.Media;
using Avalonia.UIStudio.Appearance.Model;
using ReactiveUI;

namespace Avalonia.UIStudio.Appearance.ViewModels;

public class EditableSkinViewModel : ReactiveObject
{
    public EditableSkinViewModel(Skin skin)
    {
        Skin = skin;
        Name = new ValidatableProperty<string>(nameof(Name), skin.Name);
        Description = new ValidatableProperty<string>(nameof(Description), skin.Description);

        PrimaryColor = new ValidatableProperty<Color>(nameof(PrimaryColor), skin.PrimaryColor);
        SecondaryColor = new ValidatableProperty<Color>(nameof(SecondaryColor), skin.SecondaryColor);
        PrimaryBackground = new ValidatableProperty<Color>(nameof(PrimaryBackground), skin.PrimaryBackground);
        SecondaryBackground = new ValidatableProperty<Color>(nameof(SecondaryBackground), skin.SecondaryBackground);

        AccentColor = new ValidatableProperty<Color>(nameof(AccentColor), skin.AccentColor);
        PrimaryTextColor = new ValidatableProperty<Color>(nameof(PrimaryTextColor), skin.PrimaryTextColor);
        SecondaryTextColor = new ValidatableProperty<Color>(nameof(SecondaryTextColor), skin.SecondaryTextColor);

        FontFamily = new ValidatableProperty<string>(nameof(FontFamily), skin.FontFamily.Name);


        FontSizeSmall = new ValidatableProperty<double>(nameof(FontSizeSmall), skin.FontSizeSmall);
        FontSizeMedium = new ValidatableProperty<double>(nameof(FontSizeMedium), skin.FontSizeMedium);
        FontSizeLarge = new ValidatableProperty<double>(nameof(FontSizeLarge), skin.FontSizeLarge);

        BorderRadius = new ValidatableProperty<double>(nameof(BorderRadius), skin.BorderRadius);
        BorderThickness = new ValidatableProperty<Thickness>(nameof(BorderThickness), skin.BorderThickness);
        BorderColor = new ValidatableProperty<Color>(nameof(BorderColor), skin.BorderColor);

        SuccessColor = new ValidatableProperty<Color>(nameof(SuccessColor), skin.SuccessColor);
        WarningColor = new ValidatableProperty<Color>(nameof(WarningColor), skin.WarningColor);
        ErrorColor = new ValidatableProperty<Color>(nameof(ErrorColor), skin.ErrorColor);
    }

    public Skin Skin { get; set; }


    public ValidatableProperty<string> Name { get; set; }
    public ValidatableProperty<string> Description { get; set; }

    public ValidatableProperty<Color> PrimaryColor { get; set; }
    public ValidatableProperty<Color> SecondaryColor { get; set; }
    public ValidatableProperty<Color> PrimaryBackground { get; set; }
    public ValidatableProperty<Color> SecondaryBackground { get; set; }
    public ValidatableProperty<Color> AccentColor { get; set; }
    public ValidatableProperty<Color> PrimaryTextColor { get; set; }
    public ValidatableProperty<Color> SecondaryTextColor { get; set; }
    public ValidatableProperty<string> FontFamily { get; set; }
    public ValidatableProperty<string> HeaderFontFamily { get; set; }
    public ValidatableProperty<string> BodyFontFamily { get; set; }
    public ValidatableProperty<string> MonospaceFontFamily { get; set; }
    public ValidatableProperty<double> FontSizeSmall { get; set; }
    public ValidatableProperty<double> FontSizeMedium { get; set; }
    public ValidatableProperty<double> FontSizeLarge { get; set; }

    public ValidatableProperty<double> BorderRadius { get; set; }
    public ValidatableProperty<Thickness> BorderThickness { get; set; }

    public ValidatableProperty<Color> BorderColor { get; set; }

    public ValidatableProperty<Color> SuccessColor { get; set; }
    public ValidatableProperty<Color> WarningColor { get; set; }
    public ValidatableProperty<Color> ErrorColor { get; set; }
    public ObservableCollection<EditableControlTheme> ControlThemes { get; }

    /// <summary>
    ///     Pushes edited ValidatableProperty values back into Skin model.
    ///     Call this before saving or applying.
    /// </summary>
    public void MapBackToSkin()
    {
        Skin.Name = Name.Value;
        Skin.Description = Description.Value;

        Skin.PrimaryColor = PrimaryColor.Value;
        Skin.SecondaryColor = SecondaryColor.Value;
        Skin.PrimaryBackground = PrimaryBackground.Value;
        Skin.SecondaryBackground = SecondaryBackground.Value;
        Skin.AccentColor = AccentColor.Value;
        Skin.PrimaryTextColor = PrimaryTextColor.Value;
        Skin.SecondaryTextColor = SecondaryTextColor.Value;

        Skin.FontFamily = new FontFamily(FontFamily.Value);
        Skin.FontSizeSmall = FontSizeSmall.Value;
        Skin.FontSizeMedium = FontSizeMedium.Value;
        Skin.FontSizeLarge = FontSizeLarge.Value;

        Skin.BorderRadius = BorderRadius.Value;
        Skin.BorderThickness = BorderThickness.Value;
        Skin.BorderColor = BorderColor.Value;

        Skin.SuccessColor = SuccessColor.Value;
        Skin.WarningColor = WarningColor.Value;
        Skin.ErrorColor = ErrorColor.Value;
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\ViewModels\PropertyGridViewModel.cs
================================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Avalonia.UIStudio.Appearance.ViewModels
{
    internal class PropertyGridViewModel
    {
    }
}

================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\ViewModels\PropertyGroupViewModel.cs
================================================================================

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Avalonia.UIStudio.Appearance.ViewModels
{
    public class PropertyGroupViewModel
    {
        public string GroupName { get; }
        public ObservableCollection<PropertyViewModel> Properties { get; }

        public PropertyGroupViewModel(string name, IEnumerable<PropertyViewModel> props)
        {
            GroupName = name;
            Properties = new ObservableCollection<PropertyViewModel>(props);
        }
    }

}

================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\ViewModels\PropertyViewModel.cs
================================================================================

using ReactiveUI;

namespace Avalonia.UIStudio.Appearance.ViewModels;

public abstract class PropertyViewModel : ReactiveObject
{
    public string DisplayName { get; set; } = string.Empty;
    public abstract object? Value { get; set; }
    public virtual string GroupName => GetType().Name.Replace("PropertyViewModel", string.Empty);
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\ViewModels\PropertyViewModels.cs
================================================================================

using Avalonia.Media;
using Avalonia.UIStudio.Appearance.Model;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Avalonia.UIStudio.Appearance.ViewModels
{
    public class BoolPropertyViewModel : ReflectedPropertyViewModelBase<bool>
    {
        public BoolPropertyViewModel(object target, PropertyInfo property) : base(target, property)
        {
        }
    }

    public class ColorPropertyViewModel : ReflectedPropertyViewModelBase<Color>
    {
        public ColorPropertyViewModel(object target, PropertyInfo property) : base(target, property)
        {
        }
    }

    public class NumericPropertyViewModel : ReflectedPropertyViewModelBase<double>
    {
        public NumericPropertyViewModel(object target, PropertyInfo property) : base(target, property)
        {
        }
    }

    public class EnumPropertyViewModel : ReflectedPropertyViewModelBase<Enum>
    {
        public EnumPropertyViewModel(object target, PropertyInfo property) : base(target, property)
        {
        }
    }

    public class StringPropertyViewModel : ReflectedPropertyViewModelBase<string>
    {
        public StringPropertyViewModel(object target, PropertyInfo property) : base(target, property)
        {
        }
    }

    public class DateTimePropertyViewModel : ReflectedPropertyViewModelBase<DateTime>
    {
        public DateTimePropertyViewModel(object target, PropertyInfo property) : base(target, property)
        {
        }
    }

    public class TimeSpanPropertyViewModel : ReflectedPropertyViewModelBase<TimeSpan>
    {
        public TimeSpanPropertyViewModel(object target, PropertyInfo property) : base(target, property)
        {
        }
    }

    public class UriPropertyViewModel : ReflectedPropertyViewModelBase<Uri>
    {
        public UriPropertyViewModel(object target, PropertyInfo property) : base(target, property)
        {
        }
    }

    public class FontFamilyPropertyViewModel : ReflectedPropertyViewModelBase<FontFamily>
    {
        public FontFamilyPropertyViewModel(object target, PropertyInfo property) : base(target, property)
        {
        }
    }

    public class ThicknessPropertyViewModel : ReflectedPropertyViewModelBase<Thickness>
    {
        public ThicknessPropertyViewModel(object target, PropertyInfo property) : base(target, property)
        {
        }
    }

    public class TypographyPropertyViewModel : ReflectedPropertyViewModelBase<SerializableTypography>
    {
        public TypographyPropertyViewModel(object target, PropertyInfo property) : base(target, property)
        {
        }
    }

    public class SkinPropertyViewModel : ReflectedPropertyViewModelBase<SerializableSkin>
    {
        public SkinPropertyViewModel(object target, PropertyInfo property) : base(target, property)
        {
        }
    }

    public class StringListPropertyViewModel : ReflectedPropertyViewModelBase<List<string>>
    {
        public StringListPropertyViewModel(object target, PropertyInfo property) : base(target, property)
        {
        }

    }

    public class ObjectListPropertyViewModel : ReflectedPropertyViewModelBase<List<object>>
    {
        public ObjectListPropertyViewModel(object target, PropertyInfo property) : base(target, property)
        {
        }

    }

    public class ObjectPropertyViewModel : ReflectedPropertyViewModelBase<object>
    {
        public ObjectPropertyViewModel(object target, PropertyInfo property) : base(target, property)
        {
        }

    }
}

================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\ViewModels\QuickSkinSwitcherViewModel.cs
================================================================================

using System.Collections.ObjectModel;
using Avalonia.Media;
using Avalonia.UIStudio.Appearance.Interfaces;
using Avalonia.UIStudio.Appearance.Model;
using Avalonia.UIStudio.Appearance.Services;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using ReactiveUI;

namespace Avalonia.UIStudio.Appearance.ViewModels;

/// <summary>
/// </summary>
public class QuickSkinSwitcherViewModel : ViewModelBase, IQuickSkinSwitcherViewModel
{
    private readonly ILogger _logger;
    private readonly ISkinManager _skinManager;
    private SkinSummaryInfo? _selectedSkin;

    /// <summary>
    ///     Initializes a new instance of the <see cref="QuickSkinSwitcherViewModel" /> class
    ///     with a default logger instance.
    /// </summary>
    public QuickSkinSwitcherViewModel(ISkinManager skinManager) : this(
        NullLogger.Instance, skinManager)
    {
    }

    /// <summary>
    ///     Initializes a new instance of the <see cref="QuickSkinSwitcherViewModel" /> class
    ///     with the specified logger instance.
    /// </summary>
    /// <param name="logger">
    ///     An instance of <see cref="ILogger" /> used for logging operations within the view model.
    /// </param>
    /// <param name="skinManager"></param>
    public QuickSkinSwitcherViewModel(ILogger logger, ISkinManager skinManager)
    {
        _logger = logger;
        _skinManager = skinManager;
        AvailableSkins = new ObservableCollection<SkinSummaryInfo>();

        LoadAvailableSkins();
        LoadCurrentSkin();

        // Subscribe to skin manager changes to keep in sync
        skinManager.SkinChanged += OnSkinChanged;
    }

    /// <summary>
    ///     Gets the collection of available skins that can be selected and applied
    ///     within the application.
    /// </summary>
    /// <remarks>
    ///     This property is populated by the <see cref="LoadAvailableSkins" /> method,
    ///     which retrieves the skins from the <see cref="SkinManager" />. The collection
    ///     is updated dynamically to reflect the available skins.
    /// </remarks>
    public ObservableCollection<SkinSummaryInfo> AvailableSkins { get; }

    /// <summary>
    ///     Gets or sets the currently selected skin.
    /// </summary>
    /// <remarks>
    ///     When a new skin is selected, the corresponding skin is applied automatically.
    ///     The selected skin is synchronized with the <see cref="AvailableSkins" /> collection.
    /// </remarks>
    public SkinSummaryInfo? SelectedSkin
    {
        get => _selectedSkin;
        set
        {
            if (this.RaiseAndSetIfChanged(ref _selectedSkin, value) != null) ApplySkin(value);
        }
    }

    private void LoadAvailableSkins()
    {
        try
        {
            var skinNames = _skinManager.GetAvailableSkinNames();

            AvailableSkins.Clear();

            foreach (var skinName in skinNames)
            {
                var skin = _skinManager.GetSkin(skinName);
                if (skin != null)
                {
                    var skinSummaryInfo = new SkinSummaryInfo
                    {
                        Name = skinName,
                        Description = GetSkinDescription(skinName),
                        PreviewColor = new SolidColorBrush(skin.AccentColor)
                    };
                    AvailableSkins.Add(skinSummaryInfo);
                }
            }

            _logger.LogDebug("Loaded {ThemeCount} themes for quick switcher", AvailableSkins.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load skins for quick switcher");
        }
    }

    private void LoadCurrentSkin()
    {
        try
        {
            var currentSkin = _skinManager.CurrentSkin;
            if (currentSkin?.Name != null)
            {
                var currentSkinItem = AvailableSkins.FirstOrDefault(t => t.Name == currentSkin.Name);
                if (currentSkinItem != null)
                {
                    // Set without triggering the setter to avoid recursive application
                    _selectedSkin = currentSkinItem;
                    this.RaisePropertyChanged(nameof(SelectedSkin));
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load current skin for quick switcher");
        }
    }

    private void ApplySkin(SkinSummaryInfo? skinInfo)
    {
        try
        {
            if (skinInfo != null)
            {
                _skinManager.ApplySkin(skinInfo.Name);
                _logger.LogInformation("Quick skin switch to: {ThemeName}", skinInfo.Name);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to apply skin via quick switcher: {ThemeName}", skinInfo?.Name);
        }
    }

    private void OnSkinChanged(object? sender, EventArgs e)
    {
        // Update selected skin when skin changes externally
        try
        {
            LoadCurrentSkin();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to update quick switcher after skin change");
        }
    }

    private static string GetSkinDescription(string skinName)
    {
        return skinName switch
        {
            "Dark" => "Professional dark skin",
            "Light" => "Clean light skin",
            "Ocean Blue" => "Deep blue ocean skin",
            "Forest Green" => "Nature-inspired green",
            "Purple Haze" => "Rich purple skin",
            "High Contrast" => "Maximum contrast",
            "Cyberpunk" => "Futuristic neon skin",
            _ => "Custom skin"
        };
    }

    /// <summary>
    ///     Releases the resources used by the <see cref="QuickSkinSwitcherViewModel" /> class.
    /// </summary>
    /// <param name="disposing">
    ///     A value indicating whether the method is being called explicitly to release managed resources.
    ///     If <c>true</c>, managed resources are released; otherwise, only unmanaged resources are released.
    /// </param>
    protected override void Dispose(bool disposing)
    {
        if (disposing) _skinManager.SkinChanged -= OnSkinChanged;
        base.Dispose(disposing);
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\ViewModels\ReflectedPropertyViewModel.cs
================================================================================

using System.Reflection;
using ReactiveUI;

namespace Avalonia.UIStudio.Appearance.ViewModels;

public abstract class ReflectedPropertyViewModelBase<T> : PropertyViewModel
{
    private readonly object _target;
    private readonly PropertyInfo _property;

    protected ReflectedPropertyViewModelBase(object target, PropertyInfo property)
    {
        _target = target;
        _property = property;
        DisplayName = property.Name;
    }

    public override object? Value
    {
        get => _property.GetValue(_target);
        set
        {
            _property.SetValue(_target, value);
            this.RaisePropertyChanged();
        }
    }

    public T? TypedValue
    {
        get => (T?)_property.GetValue(_target);
        set
        {
            _property.SetValue(_target, value);
            this.RaisePropertyChanged(nameof(Value));
            this.RaisePropertyChanged(nameof(TypedValue));
        }
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\ViewModels\SkinSettingsViewModel.cs
================================================================================

using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Reactive;
using Avalonia.Media;
using Avalonia.UIStudio.Appearance.Interfaces;
using Avalonia.UIStudio.Appearance.Model;
using Avalonia.UIStudio.Appearance.Services;
using Microsoft.Extensions.Logging;
using ReactiveUI;

namespace Avalonia.UIStudio.Appearance.ViewModels;

public class SkinSettingsViewModel : ViewModelBase
{
    private readonly ILogger _logger;
    private readonly ISkinImportExportService _skinImportExportService;
    private readonly ISkinManager _skinManager;
    private readonly SkinValidator _skinValidator = new();

    private EditableSkinViewModel? _editableSkin;
    private bool _isApplyingSkin;

    private bool _isEditMode;
    private bool _isSubscribedToSkinChanged;
    private SkinSummaryInfo? _selectedSkin;
    private Color _validatedPrimaryColor;
    private SkinValidationResult? _validationResult;

    //public SkinSettingsViewModel() : this(
    //    Microsoft.Extensions.Logging.Abstractions.NullLogger.Instance, SkinManager.Instance)
    //{
    //}

    public SkinSettingsViewModel(ILogger<SkinSettingsViewModel> logger, ISkinManager skinManager,
        ISkinImportExportService skinImportExportService)
    {
        _logger = logger;
        _skinManager = skinManager;
        _skinImportExportService = skinImportExportService;
        AvailableSkins = new ObservableCollection<SkinSummaryInfo>();
        ApplySkinCommand = ReactiveCommand.Create(ApplySkin);
        ApplyChangesCommand = ReactiveCommand.Create(SaveChanges);
        _skinManager.SkinChanged += _skinManager_SkinChanged;
        _isSubscribedToSkinChanged = true;
        LoadAvailableSkins();
        LoadCurrentSkin();
    }

    public ObservableCollection<SkinSummaryInfo> AvailableSkins { get; }

    public ReactiveCommand<Unit, Unit> ApplySkinCommand { get; }
    public ReactiveCommand<Unit, Unit> ApplyChangesCommand { get; }

    public SkinSummaryInfo? SelectedSkin
    {
        get => _selectedSkin;
        set
        {
            if (this.RaiseAndSetIfChanged(ref _selectedSkin, value) != null)
                if (value != null && !_isApplyingSkin)
                {
                    _isApplyingSkin = true;

                    _skinManager.ApplySkin(value.Name);
                    _logger.LogInformation("Skin changed to: {ThemeName}", value.Name);

                    LoadEditableSkin();

                    _isApplyingSkin = false;
                }
        }
    }

    public EditableSkinViewModel? EditableSkin
    {
        get => _editableSkin;
        private set
        {
            if (this.RaiseAndSetIfChanged(ref _editableSkin, value) != null)
            {
                AttachPropertyChangedHandler();
                ValidateSkin();
            }
        }
    }

    // Renamed and fixed: ValidatedProperties is a stable dictionary
    public Dictionary<string, ValidatedProperty> ValidatedProperties { get; } = new();

    // Added: indexer so you can use {Binding [FontSizeLarge]} in XAML
    public ValidatedProperty? this[string propertyName]
    {
        get
        {
            ValidatedProperties.TryGetValue(propertyName, out var vp);
            return vp;
        }
    }

    public SkinValidationResult? ValidationResult
    {
        get => _validationResult;
        private set
        {
            this.RaiseAndSetIfChanged(ref _validationResult, value);

            // Clear and repopulate ValidatedProperties dictionary
            ValidatedProperties.Clear();

            if (ValidationResult != null)
                foreach (var result in ValidationResult.ValidationMessages)
                foreach (var prop in result.InvolvedProperties)
                {
                    var add = new ValidatedProperty
                    {
                        OriginalMessage = result,
                        Message = result.Message,
                        IsValid = !result.IsError,
                        Name = prop
                    };

                    if (result.SuggestedValues.TryGetValue(prop, out var suggestedValue))
                        add.SuggestedValue = suggestedValue;

                    ValidatedProperties[prop] = add;
                }

            // Notify UI that dictionary contents changed
            this.RaisePropertyChanged(nameof(ValidatedProperties));
            this.RaisePropertyChanged(nameof(Errors));
            this.RaisePropertyChanged(nameof(Warnings));
        }
    }

    public List<string> Errors => ValidationResult?.Errors ?? new List<string>();
    public List<string> Warnings => ValidationResult?.Warnings ?? new List<string>();

    public bool IsEditMode
    {
        get => _isEditMode;
        set => this.RaiseAndSetIfChanged(ref _isEditMode, value);
    }

    private void _skinManager_SkinChanged(object? sender, EventArgs e)
    {
        if (_isApplyingSkin)
            // Skip handling SkinChanged caused by our own ApplySkin
            return;

        _logger.LogInformation("SkinChanged detected. Reloading EditableSkin.");
        LoadEditableSkin();
        ValidateSkin();
    }

    public void ResetToDefault()
    {
        try
        {
            var defaultSkin = AvailableSkins.FirstOrDefault(t => t.Name == "Dark");
            if (defaultSkin != null)
            {
                SelectedSkin = defaultSkin;
                _logger.LogInformation("Reset to default skin: Dark");
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to reset to default skin");
        }
    }

    private void LoadAvailableSkins()
    {
        try
        {
            var skinNames = _skinManager?.GetAvailableSkinNames();

            AvailableSkins.Clear();

            if (skinNames != null)
                foreach (var skinName in skinNames)
                {
                    var skin = _skinManager?.GetSkin(skinName);
                    if (skin != null)
                    {
                        var skinInfo = new SkinSummaryInfo
                        {
                            Name = skinName,
                            Description = GetSkinDescription(skinName),
                            PreviewColor = new SolidColorBrush(skin.AccentColor)
                        };
                        AvailableSkins.Add(skinInfo);
                    }
                }

            _logger.LogInformation("Loaded {ThemeCount} available skins", AvailableSkins.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load available skins");
        }
    }

    private void LoadCurrentSkin()
    {
        try
        {
            var currentSkin = _skinManager.CurrentSkin;
            if (currentSkin?.Name != null)
                SelectedSkin = AvailableSkins.FirstOrDefault(t => t.Name == currentSkin.Name);

            SelectedSkin ??= AvailableSkins.FirstOrDefault(t => t.Name == "Dark");

            LoadEditableSkin();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load current skin");
        }
    }

    private void LoadEditableSkin()
    {
        var currentSkin = _skinManager.CurrentSkin;
        if (currentSkin != null) EditableSkin = new EditableSkinViewModel(CloneSkin(currentSkin));
    }

    private void ApplySkin()
    {
        try
        {
            if (SelectedSkin != null && !_isApplyingSkin)
            {
                _isApplyingSkin = true;

                _skinManager.ApplySkin(SelectedSkin.Name);
                SkinManager.Instance.ApplySkin(SelectedSkin.Name);
                _logger.LogInformation("Applied skin: {ThemeName}", SelectedSkin.Name);

                LoadEditableSkin();

                _isApplyingSkin = false;
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to apply skin: {ThemeName}", SelectedSkin?.Name);
            _isApplyingSkin = false; // Ensure flag is reset even on exception
        }
    }

    private async void SaveChanges()
    {
        try
        {
            if (EditableSkin?.Skin != null)
            {
                // 1️⃣ First: push ValidatableProperty values back to Skin
                EditableSkin.MapBackToSkin();
                var userOverridePath = $"./Skins/UserOverrides/{EditableSkin.Skin.Name}/skin.json";
                Directory.CreateDirectory(Path.GetDirectoryName(userOverridePath)!);

                await _skinImportExportService.ExportSkinAsync(EditableSkin.Skin, userOverridePath);

                _logger.LogInformation("Saved edited skin to: {FilePath}", userOverridePath);

                // 3️⃣ Reload available skins so SkinManager knows the updated version
                _skinManager.ReloadSkins();

                // 4️⃣ Re-apply the saved skin from SkinManager
                _skinManager.ApplySkin(EditableSkin.Skin.Name);

                _logger.LogInformation("Reloaded and re-applied saved skin: {SkinName}", EditableSkin.Skin.Name);

                // 5️⃣ Reload EditableSkin with the fresh saved version
                LoadEditableSkin();
                var currentSkin = _skinManager.CurrentSkin;
                if (currentSkin?.Name != null)
                    SelectedSkin = AvailableSkins.FirstOrDefault(t => t.Name == currentSkin.Name);
                ValidateSkin();
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to save and apply edited skin");
        }
    }


    private void ValidateSkin()
    {
        if (EditableSkin?.Skin == null) return;

        var result = _skinValidator.ValidateSkin(EditableSkin.Skin);
        ValidationResult = result;

        _logger.LogInformation("Validated EditableSkin: {ErrorCount} errors, {WarningCount} warnings",
            result.Errors.Count, result.Warnings.Count);
    }

    private void AttachPropertyChangedHandler()
    {
        if (EditableSkin != null)
        {
            EditableSkin.PropertyChanged -= EditableSkin_PropertyChanged;
            EditableSkin.PropertyChanged += EditableSkin_PropertyChanged;
        }
    }

    private void EditableSkin_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        ValidateSkin();
    }

    private Skin CloneSkin(Skin original)
    {
        return new Skin
        {
            Name = original.Name,
            Description = original.Description,
            PrimaryColor = original.PrimaryColor,
            SecondaryColor = original.SecondaryColor,
            AccentColor = original.AccentColor,
            PrimaryBackground = original.PrimaryBackground,
            SecondaryBackground = original.SecondaryBackground,
            PrimaryTextColor = original.PrimaryTextColor,
            SecondaryTextColor = original.SecondaryTextColor,
            FontFamily = original.FontFamily,
            FontSizeSmall = original.FontSizeSmall,
            FontSizeMedium = original.FontSizeMedium,
            FontSizeLarge = original.FontSizeLarge,
            FontWeight = original.FontWeight,
            BorderColor = original.BorderColor,
            BorderThickness = original.BorderThickness,
            BorderRadius = original.BorderRadius,
            ErrorColor = original.ErrorColor,
            WarningColor = original.WarningColor,
            SuccessColor = original.SuccessColor,
            Typography = original.Typography?.Clone(),
            ControlThemeUris = original.ControlThemeUris,
            StyleUris = original.StyleUris,
            AssetUris = original.AssetUris,
            HeaderFontFamily = original.HeaderFontFamily,
            BodyFontFamily = original.BodyFontFamily,
            MonospaceFontFamily = original.MonospaceFontFamily,
            LineHeight = original.LineHeight,
            LetterSpacing = original.LetterSpacing,
            EnableLigatures = original.EnableLigatures
        };
    }

    private static string GetSkinDescription(string skinName)
    {
        return skinName switch
        {
            "Dark" => "Professional dark skin with blue accents. Easy on the eyes for extended use.",
            "Light" => "Clean light skin with dark text. Perfect for bright environments.",
            "Ocean Blue" => "Deep blue skin inspired by ocean depths. Calming and focused.",
            "Forest Green" => "Nature-inspired green skin. Relaxing and earthy.",
            "Purple Haze" => "Rich purple skin with mystical vibes. Creative and bold.",
            "High Contrast" => "Maximum contrast for accessibility. Clear and distinct colors.",
            "Cyberpunk" => "Futuristic neon skin with hot pink accents. Edgy and modern.",
            _ => "Custom skin with unique color combinations."
        };
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\ViewModels\ViewModelBase.cs
================================================================================

using ReactiveUI;

namespace Avalonia.UIStudio.Appearance.ViewModels;

/// <summary>
///     Serves as the base class for all ViewModel classes in the AvaloniaSkinManager application.
/// </summary>
/// <remarks>
///     This class provides common functionality for ViewModel classes, including support for
///     reactive property changes and resource management through the <see cref="IDisposable" /> interface.
/// </remarks>
public class ViewModelBase : ReactiveObject, IDisposable
{
    /// <summary>
    ///     Releases all resources used by the <see cref="ViewModelBase" /> instance.
    /// </summary>
    /// <remarks>
    ///     This method calls the <see cref="Dispose(bool)" /> method with a value of <c>true</c>
    ///     to release managed resources and suppresses finalization of the object.
    /// </remarks>
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    /// <summary>
    ///     Releases all resources used by the <see cref="ViewModelBase" /> instance.
    /// </summary>
    /// <remarks>
    ///     This method is part of the <see cref="IDisposable" /> implementation and ensures that
    ///     both managed and unmanaged resources are properly released. It calls the
    ///     <see cref="Dispose(bool)" /> method with a value of <c>true</c>, and suppresses
    ///     finalization of the object to prevent redundant resource cleanup.
    /// </remarks>
    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            
        }
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Views\ModalEditorDialog.axaml.cs
================================================================================

using Avalonia.Controls;
using Avalonia.Interactivity;
using Avalonia.Markup.Xaml;

namespace Avalonia.UIStudio.Appearance.Views;

public partial class ModalEditorDialog : Window
{
    public ModalEditorDialog(object data)
    {
        DataContext = data;
        InitializeComponent();
    }

    private void Control_OnLoaded(object? sender, RoutedEventArgs e)
    {
        PropertyGridMain.SelectedObject = DataContext;
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Views\ModalListEditorDialog.axaml.cs
================================================================================

using Avalonia.Controls;

namespace Avalonia.UIStudio.Appearance.Views;

public partial class ModalListEditorDialog : Window
{
    public ModalListEditorDialog(IEnumerable<object> list)
    {
        DataContext = list;
        InitializeComponent();
        ItemsControlMain.ItemsSource = list;
    }

}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Views\SkinSettingsDialog.axaml.cs
================================================================================

using Avalonia.Controls;
using Avalonia.Interactivity;
using Avalonia.UIStudio.Appearance.Extensions;
using Avalonia.UIStudio.Appearance.ViewModels;
using Microsoft.Extensions.DependencyInjection;

namespace Avalonia.UIStudio.Appearance.Views;

/// <summary>
///     Represents a dialog window for managing skin settings in the application.
/// </summary>
/// <remarks>
///     This class provides a user interface for selecting, applying, and resetting skins.
///     It is backed by the <see cref="SkinSettingsViewModel" />
///     to handle the logic and data binding for skin management.
/// </remarks>
public partial class SkinSettingsDialog : Window
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="SkinSettingsDialog" /> class.
    /// </summary>
    /// <remarks>
    ///     This constructor sets up the dialog by initializing its components and
    ///     assigning a new instance of <see cref="SkinSettingsViewModel" /> as its data context.
    /// </remarks>
    public SkinSettingsDialog()
    {
        InitializeComponent();
        DataContext = Application.Current.GetRequiredService<SkinSettingsViewModel>();
    }

    public SkinSettingsDialog(IServiceProvider serviceProvider)
    {
        InitializeComponent();
        var viewModel = serviceProvider.GetRequiredService<SkinSettingsViewModel>();
        DataContext = viewModel;
    }

    private void ResetButton_Click(object? sender, RoutedEventArgs e)
    {
        if (DataContext is SkinSettingsViewModel viewModel) viewModel.ResetToDefault();
    }

    private void CloseButton_Click(object? sender, RoutedEventArgs e)
    {
        Close();
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Services\ValidationRules\AccessibilityValidationRule.cs
================================================================================

using Avalonia.Media;
using Avalonia.UIStudio.Appearance.Interfaces;
using Avalonia.UIStudio.Appearance.Model;

namespace Avalonia.UIStudio.Appearance.Services.ValidationRules;

public class AccessibilityValidationRule : ISkinValidationRule
{
    public List<SkinValidationMessage> Validate(Skin skin)
    {
        var result = new SkinValidationResult();

        // Text & background contrast
        ValidateContrast(result, "PrimaryTextColor", skin.PrimaryTextColor, skin.PrimaryBackground);
        ValidateContrast(result, "SecondaryTextColor", skin.SecondaryTextColor, skin.PrimaryBackground);
        ValidateContrast(result, "BorderColor", skin.BorderColor, skin.PrimaryBackground);

        // Font sizes
        ValidateFontSize(result, "FontSizeSmall", skin.FontSizeSmall, 12.0, 20.0);
        ValidateFontSize(result, "FontSizeMedium", skin.FontSizeMedium, 14.0, 24.0);
        ValidateFontSize(result, "FontSizeLarge", skin.FontSizeLarge, 18.0, 32.0);


        // Feedback colors
        ValidateContrast(result, "WarningColor", skin.WarningColor, skin.PrimaryBackground);
        ValidateContrast(result, "SuccessColor", skin.SuccessColor, skin.PrimaryBackground);
        ValidateContrast(result, "ErrorColor", skin.ErrorColor, skin.PrimaryBackground);

        ValidateVisualStability(result, skin);


        // Optional info-level UX guidance: warning vs success similarity
        if (AreStatusColorsTooSimilar(skin.WarningColor, skin.SuccessColor))
            result.ValidationMessages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = "WarningColor and SuccessColor are perceptually too similar.",
                InvolvedProperties = new List<string> { "WarningColor", "SuccessColor" }
            });
        // Update IsValid
        result.IsValid = !result.ValidationMessages.Any(vm => vm.IsError);

        return result.ValidationMessages;
    }

    public void ValidateStatusColorDifferentiation(SkinValidationResult result, Skin skin)
    {
        ValidateColorSimilarity(result, "WarningColor", skin.WarningColor, "SuccessColor", skin.SuccessColor);
        ValidateColorSimilarity(result, "WarningColor", skin.WarningColor, "ErrorColor", skin.ErrorColor);
        ValidateColorSimilarity(result, "SuccessColor", skin.SuccessColor, "ErrorColor", skin.ErrorColor);
    }

    public void ValidateColorSimilarity(SkinValidationResult result, string nameA, Color a, string nameB, Color b)
    {
        if (AreStatusColorsTooSimilar(a, b))
            result.ValidationMessages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = $"{nameA} and {nameB} are perceptually too similar.",
                InvolvedProperties = new List<string> { nameA, nameB }
            });
    }


    public bool AreColorsHueSimilar(Color c1, Color c2, double hueThreshold = 30)
    {
        var h1 = RgbToHue(c1);
        var h2 = RgbToHue(c2);
        var diff = Math.Abs(h1 - h2);
        return diff < hueThreshold || diff > 360 - hueThreshold;
    }

    public bool AreStatusColorsTooSimilar(Color a, Color b)
    {
        var hueDiff = Math.Abs(RgbToHue(a) - RgbToHue(b));
        var lumDiff = Math.Abs(RelativeLuminance(a) - RelativeLuminance(b));
        return hueDiff < 30 && lumDiff < 0.2;
    }

    private double RgbToHue(Color color)
    {
        var r = color.R / 255.0;
        var g = color.G / 255.0;
        var b = color.B / 255.0;

        var max = Math.Max(r, Math.Max(g, b));
        var min = Math.Min(r, Math.Min(g, b));
        var delta = max - min;

        if (delta == 0) return 0;

        if (max == r)
            return 60 * ((g - b) / delta % 6);
        if (max == g)
            return 60 * ((b - r) / delta + 2);
        // max == b
        return 60 * ((r - g) / delta + 4);
    }

    private void ValidateVisualStability(SkinValidationResult result, Skin skin)
    {
        ValidateColorSaturation(result, "AccentColor", skin.AccentColor);
        ValidateColorSaturation(result, "ErrorColor", skin.ErrorColor);
    }

    private void ValidateColorSaturation(SkinValidationResult result, string propertyName, Color color)
    {
        if (IsHighSaturationColor(color))
            result.ValidationMessages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = $"{propertyName} uses very bright, saturated colors.",
                InvolvedProperties = new List<string> { propertyName }
            });
    }

    private bool IsHighSaturationColor(Color color)
    {
        var r = color.R / 255.0;
        var g = color.G / 255.0;
        var b = color.B / 255.0;

        var max = Math.Max(r, Math.Max(g, b));
        var min = Math.Min(r, Math.Min(g, b));
        var saturation = max == 0 ? 0 : (max - min) / max;

        return saturation > 0.8;
    }

    private void ValidateContrast(SkinValidationResult result, string propertyName, Color fg, Color bg)
    {
        var contrast = ContrastRatio(fg, bg);
        if (contrast < 4.5)
            result.ValidationMessages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = $"{propertyName} contrast vs background is too low ({contrast:F2}:1).",
                InvolvedProperties = new List<string> { propertyName, "PrimaryBackground" },
                SuggestedValues = new Dictionary<string, object?>
                {
                    { propertyName, SuggestBetterColor(fg, bg) }
                }
            });
    }

    private void ValidateFontSize(SkinValidationResult result, string propertyName, double px, double min, double max)
    {
        if (px < min)
            result.ValidationMessages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = $"{propertyName} ({px}px) is below minimum of {min}px.",
                InvolvedProperties = new List<string> { propertyName },
                SuggestedValues = new Dictionary<string, object?>
                {
                    { propertyName, min }
                }
            });
        else if (px > max)
            result.ValidationMessages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = $"{propertyName} ({px}px) is unusually large — consider reducing (max recommended {max}px).",
                InvolvedProperties = new List<string> { propertyName },
                SuggestedValues = new Dictionary<string, object?>
                {
                    { propertyName, max }
                }
            });
    }

    public void ValidateFontSize(SkinValidationResult result, Skin skin)
    {
        ValidateFontSize(result, "FontSizeSmall", skin.FontSizeSmall, 12.0, 20.0);
        ValidateFontSize(result, "FontSizeMedium", skin.FontSizeMedium, 14.0, 24.0);
        ValidateFontSize(result, "FontSizeLarge", skin.FontSizeLarge, 18.0, 32.0);
    }


    public void ValidateStatusColors(SkinValidationResult result, Skin skin)
    {
        ValidateContrast(result, "WarningColor", skin.WarningColor, skin.PrimaryBackground);
        ValidateContrast(result, "SuccessColor", skin.SuccessColor, skin.PrimaryBackground);
        ValidateContrast(result, "ErrorColor", skin.ErrorColor, skin.PrimaryBackground);
    }


    private double ContrastRatio(Color c1, Color c2)
    {
        var L1 = RelativeLuminance(c1);
        var L2 = RelativeLuminance(c2);
        return (Math.Max(L1, L2) + 0.05) / (Math.Min(L1, L2) + 0.05);
    }

    private double RelativeLuminance(Color color)
    {
        var R = ToLinear(color.R / 255.0);
        var G = ToLinear(color.G / 255.0);
        var B = ToLinear(color.B / 255.0);
        return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    }

    private double ToLinear(double channel)
    {
        return channel <= 0.03928 ? channel / 12.92 : Math.Pow((channel + 0.055) / 1.055, 2.4);
    }

    // Optionally: suggest a slightly darker/lighter color for better contrast
    private Color SuggestBetterColor(Color original, Color background)
    {
        var contrast = ContrastRatio(original, background);

        // If contrast too low, suggest darkening
        if (contrast < 4.5)
        {
            var factor = 0.8; // Darken by 20%
            return Color.FromRgb(
                (byte)(original.R * factor),
                (byte)(original.G * factor),
                (byte)(original.B * factor));
        }

        return original; // Already acceptable
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Services\ValidationRules\BorderValidationRule.cs
================================================================================

using Avalonia.UIStudio.Appearance.Interfaces;
using Avalonia.UIStudio.Appearance.Model;

namespace Avalonia.UIStudio.Appearance.Services.ValidationRules;

public class BorderValidationRule : ISkinValidationRule
{
    public List<SkinValidationMessage> Validate(Skin skin)
    {
        var messages = new List<SkinValidationMessage>();

        ValidateBorderThickness(skin, messages);
        ValidateBorderRadius(skin, messages);
        ValidateBorderColorContrast(skin, messages);

        return messages;
    }

    private void ValidateBorderThickness(Skin skin, List<SkinValidationMessage> messages)
    {
        var thickness = skin.BorderThickness;

        // Negative values
        if (thickness.Left < 0 || thickness.Top < 0 || thickness.Right < 0 || thickness.Bottom < 0)
            messages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = "Border thickness values cannot be negative.",
                InvolvedProperties = new List<string> { "BorderThickness" },
                SuggestedValues = new Dictionary<string, object?>
                {
                    {
                        "BorderThickness",
                        new Thickness(Math.Max(0, thickness.Left), Math.Max(0, thickness.Top),
                            Math.Max(0, thickness.Right), Math.Max(0, thickness.Bottom))
                    }
                }
            });

        // Excessive thickness
        var maxThickness = Math.Max(Math.Max(thickness.Left, thickness.Right),
            Math.Max(thickness.Top, thickness.Bottom));

        if (maxThickness > 10)
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = $"Border thickness ({maxThickness}) is very large and may impact usability.",
                InvolvedProperties = new List<string> { "BorderThickness" },
                SuggestedValues = new Dictionary<string, object?>
                {
                    {
                        "BorderThickness", new Thickness(
                            Math.Min(thickness.Left, 10),
                            Math.Min(thickness.Top, 10),
                            Math.Min(thickness.Right, 10),
                            Math.Min(thickness.Bottom, 10))
                    }
                }
            });

        // All zero thickness
        if (thickness.Left == 0 && thickness.Top == 0 && thickness.Right == 0 && thickness.Bottom == 0)
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = "All border thickness values are zero — borders will be invisible.",
                InvolvedProperties = new List<string> { "BorderThickness" },
                SuggestedValues = new Dictionary<string, object?>()
            });
    }

    private void ValidateBorderRadius(Skin skin, List<SkinValidationMessage> messages)
    {
        var radius = skin.BorderRadius;

        // Negative radius
        if (radius < 0)
            messages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = $"Border radius ({radius}) cannot be negative.",
                InvolvedProperties = new List<string> { "BorderRadius" },
                SuggestedValues = new Dictionary<string, object?>
                {
                    { "BorderRadius", 0.0 }
                }
            });

        // Excessive radius
        if (radius > 50)
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = $"Border radius ({radius}) is very large and may cause visual issues.",
                InvolvedProperties = new List<string> { "BorderRadius" },
                SuggestedValues = new Dictionary<string, object?>
                {
                    { "BorderRadius", 50.0 }
                }
            });

        // Very small radius
        if (radius > 0 && radius < 1)
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = $"Border radius ({radius}) is very small and may not be visible.",
                InvolvedProperties = new List<string> { "BorderRadius" },
                SuggestedValues = new Dictionary<string, object?>
                {
                    { "BorderRadius", 1.0 }
                }
            });
    }

    private void ValidateBorderColorContrast(Skin skin, List<SkinValidationMessage> messages)
    {
        var validator = new SkinValidator();

        // Border vs PrimaryBackground
        var primaryBorderContrast = validator.CalculateContrastRatio(skin.BorderColor, skin.PrimaryBackground);
        if (primaryBorderContrast < 1.5)
            messages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message =
                    $"Border color has insufficient contrast against primary background (ratio: {primaryBorderContrast:F2}).",
                InvolvedProperties = new List<string> { "BorderColor", "PrimaryBackground" },
                SuggestedValues = new Dictionary<string, object?>
                {
                    { "BorderColor", validator.AdjustColorForContrast(skin.BorderColor, skin.PrimaryBackground, 1.5) },
                    { "PrimaryBackground", null }
                }
            });
        else if (primaryBorderContrast < 2.0)
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message =
                    $"Border color has low contrast against primary background (ratio: {primaryBorderContrast:F2}).",
                InvolvedProperties = new List<string> { "BorderColor", "PrimaryBackground" },
                SuggestedValues = new Dictionary<string, object?>
                {
                    { "BorderColor", validator.AdjustColorForContrast(skin.BorderColor, skin.PrimaryBackground, 2.0) },
                    { "PrimaryBackground", null }
                }
            });

        // Border vs SecondaryBackground
        var secondaryBorderContrast = validator.CalculateContrastRatio(skin.BorderColor, skin.SecondaryBackground);
        if (secondaryBorderContrast < 1.5)
            messages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message =
                    $"Border color has insufficient contrast against secondary background (ratio: {secondaryBorderContrast:F2}).",
                InvolvedProperties = new List<string> { "BorderColor", "SecondaryBackground" },
                SuggestedValues = new Dictionary<string, object?>
                {
                    {
                        "BorderColor", validator.AdjustColorForContrast(skin.BorderColor, skin.SecondaryBackground, 1.5)
                    },
                    { "SecondaryBackground", null }
                }
            });
        else if (secondaryBorderContrast < 2.0)
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message =
                    $"Border color has low contrast against secondary background (ratio: {secondaryBorderContrast:F2}).",
                InvolvedProperties = new List<string> { "BorderColor", "SecondaryBackground" },
                SuggestedValues = new Dictionary<string, object?>
                {
                    {
                        "BorderColor", validator.AdjustColorForContrast(skin.BorderColor, skin.SecondaryBackground, 2.0)
                    },
                    { "SecondaryBackground", null }
                }
            });

        // Border vs PrimaryTextColor
        var textSimilarity = validator.CalculateContrastRatio(skin.BorderColor, skin.PrimaryTextColor);
        if (textSimilarity < 1.2)
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = "Border color is very similar to primary text color, which may cause visual confusion.",
                InvolvedProperties = new List<string> { "BorderColor", "PrimaryTextColor" },
                SuggestedValues = new Dictionary<string, object?>()
            });
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Services\ValidationRules\ColorValidationRule.cs
================================================================================

using Avalonia.UIStudio.Appearance.Interfaces;
using Avalonia.UIStudio.Appearance.Model;

namespace Avalonia.UIStudio.Appearance.Services.ValidationRules;

public class ColorContrastValidationRule : ISkinValidationRule
{
    public List<SkinValidationMessage> Validate(Skin skin)
    {
        var messages = new List<SkinValidationMessage>();
        var validator = new SkinValidator();

        // Check primary text contrast
        var primaryContrast = validator.CalculateContrastRatio(skin.PrimaryTextColor, skin.PrimaryBackground);
        if (primaryContrast < 4.5) // WCAG AA standard
            messages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = $"Primary text contrast ratio ({primaryContrast:F2}) is below WCAG AA standard (4.5:1)",
                InvolvedProperties = new List<string> { "PrimaryTextColor", "PrimaryBackground" },
                SuggestedValues = new Dictionary<string, object?>
                {
                    {
                        "PrimaryTextColor",
                        validator.AdjustColorForContrast(skin.PrimaryTextColor, skin.PrimaryBackground, 4.5)
                    },
                    { "PrimaryBackground", null }
                }
            });
        else if (primaryContrast < 7.0) // WCAG AAA standard
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = $"Primary text contrast ratio ({primaryContrast:F2}) is below WCAG AAA standard (7.0:1)",
                InvolvedProperties = new List<string> { "PrimaryTextColor", "PrimaryBackground" },
                SuggestedValues = new Dictionary<string, object?>
                {
                    {
                        "PrimaryTextColor",
                        validator.AdjustColorForContrast(skin.PrimaryTextColor, skin.PrimaryBackground, 7.0)
                    },
                    { "PrimaryBackground", null }
                }
            });

        // Check secondary text contrast
        var secondaryContrast = validator.CalculateContrastRatio(skin.SecondaryTextColor, skin.SecondaryBackground);
        if (secondaryContrast < 3.0)
            messages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = $"Secondary text contrast ratio ({secondaryContrast:F2}) is below minimum standard (3.0:1)",
                InvolvedProperties = new List<string> { "SecondaryTextColor", "SecondaryBackground" },
                SuggestedValues = new Dictionary<string, object?>
                {
                    {
                        "SecondaryTextColor",
                        validator.AdjustColorForContrast(skin.SecondaryTextColor, skin.SecondaryBackground, 3.0)
                    },
                    { "SecondaryBackground", null }
                }
            });

        // Check accent color readability
        var accentContrast = validator.CalculateContrastRatio(skin.PrimaryTextColor, skin.AccentColor);
        if (accentContrast < 3.0)
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = $"Accent color contrast with primary text ({accentContrast:F2}) may be difficult to read",
                InvolvedProperties = new List<string> { "PrimaryTextColor", "AccentColor" },
                SuggestedValues = new Dictionary<string, object?>
                {
                    {
                        "PrimaryTextColor",
                        validator.AdjustColorForContrast(skin.PrimaryTextColor, skin.AccentColor, 3.0)
                    },
                    { "AccentColor", null }
                }
            });

        return messages;
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Services\ValidationRules\FontValidationRule.cs
================================================================================

using Avalonia.UIStudio.Appearance.Interfaces;
using Avalonia.UIStudio.Appearance.Model;

namespace Avalonia.UIStudio.Appearance.Services.ValidationRules;

public class FontSizeValidationRule : ISkinValidationRule
{
    private const double SmallMin = 8.0;
    private const double SmallMax = 20.0;
    private const double MediumMin = 10.0;
    private const double MediumMax = 24.0;
    private const double LargeMin = 12.0;
    private const double LargeMax = 32.0;

    public List<SkinValidationMessage> Validate(Skin skin)
    {
        var messages = new List<SkinValidationMessage>();

        // FontSizeSmall
        if (skin.FontSizeSmall < SmallMin || skin.FontSizeSmall > SmallMax)
            messages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = $"Small font size ({skin.FontSizeSmall}px) must be between {SmallMin} and {SmallMax} px.",
                InvolvedProperties = new List<string> { "FontSizeSmall" },
                SuggestedValues = new Dictionary<string, object?>
                {
                    { "FontSizeSmall", Math.Clamp(skin.FontSizeSmall, SmallMin, SmallMax) }
                }
            });

        // FontSizeMedium
        if (skin.FontSizeMedium < MediumMin || skin.FontSizeMedium > MediumMax)
            messages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = $"Medium font size ({skin.FontSizeMedium}px) must be between {MediumMin} and {MediumMax} px.",
                InvolvedProperties = new List<string> { "FontSizeMedium" },
                SuggestedValues = new Dictionary<string, object?>
                {
                    { "FontSizeMedium", Math.Clamp(skin.FontSizeMedium, MediumMin, MediumMax) }
                }
            });

        // FontSizeLarge
        if (skin.FontSizeLarge < LargeMin || skin.FontSizeLarge > LargeMax)
            messages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = $"Large font size ({skin.FontSizeLarge}px) must be between {LargeMin} and {LargeMax} px.",
                InvolvedProperties = new List<string> { "FontSizeLarge" },
                SuggestedValues = new Dictionary<string, object?>
                {
                    { "FontSizeLarge", Math.Clamp(skin.FontSizeLarge, LargeMin, LargeMax) }
                }
            });

        // Logical font size progression checks
        if (skin.FontSizeSmall >= skin.FontSizeMedium)
            messages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = "Small font size should be smaller than medium font size.",
                InvolvedProperties = new List<string> { "FontSizeSmall", "FontSizeMedium" },
                SuggestedValues = new Dictionary<string, object?>()
            });

        if (skin.FontSizeMedium >= skin.FontSizeLarge)
            messages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = "Medium font size should be smaller than large font size.",
                InvolvedProperties = new List<string> { "FontSizeMedium", "FontSizeLarge" },
                SuggestedValues = new Dictionary<string, object?>()
            });

        return messages;
    }
}
================================================================================
File: C:\Users\jonms\source\repos\Avalonia.UIStudio\Avalonia.UIStudio.Appearance\Services\ValidationRules\NameValidationRule.cs
================================================================================

using System.Globalization;
using System.Text.RegularExpressions;
using Avalonia.UIStudio.Appearance.Interfaces;
using Avalonia.UIStudio.Appearance.Model;

namespace Avalonia.UIStudio.Appearance.Services.ValidationRules;

public class NameValidationRule : ISkinValidationRule
{
    private const int MinLength = 2;
    private const int MaxLength = 50;
    private const int QuiteLongThreshold = 30;
    private static readonly string[] ReservedNames = { "Default", "System", "Auto", "None", "Null", "Empty" };
    private static readonly string[] GenericNames = { "Theme", "Skin", "Custom", "New" };
    private static readonly string[] ProblematicNames = { "Test", "Debug", "Temp", "Sample" };
    private static readonly string[] FilesystemConflictNames = { "con", "prn", "aux", "nul", "com1", "lpt1" };

    public List<SkinValidationMessage> Validate(Skin skin)
    {
        var messages = new List<SkinValidationMessage>();

        var name = skin.Name ?? string.Empty;

        // Empty or whitespace
        if (string.IsNullOrWhiteSpace(name))
        {
            messages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = "Skin name is empty or whitespace.",
                InvolvedProperties = new List<string> { "Name" },
                SuggestedValues = new Dictionary<string, object?> { { "Name", "Custom Skin" } }
            });
            return messages; // No point validating further if empty
        }

        name = name.Trim();

        // Too short
        if (name.Length < MinLength)
            messages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = $"Skin name is too short (minimum {MinLength} characters required).",
                InvolvedProperties = new List<string> { "Name" },
                SuggestedValues = new Dictionary<string, object?> { { "Name", "Custom Skin" } }
            });

        // Too long
        if (name.Length > MaxLength)
            messages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = $"Skin name is too long (max {MaxLength} characters allowed).",
                InvolvedProperties = new List<string> { "Name" },
                SuggestedValues = new Dictionary<string, object?> { { "Name", name.Substring(0, MaxLength) } }
            });

        // Leading/trailing whitespace
        if (skin.Name != name)
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = "Skin name has leading or trailing whitespace.",
                InvolvedProperties = new List<string> { "Name" },
                SuggestedValues = new Dictionary<string, object?> { { "Name", name } }
            });

        // Multiple consecutive spaces
        if (Regex.IsMatch(name, @" {2,}"))
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = "Skin name contains multiple consecutive spaces.",
                InvolvedProperties = new List<string> { "Name" },
                SuggestedValues = new Dictionary<string, object?> { { "Name", Regex.Replace(name, @" {2,}", " ") } }
            });

        // Starts with special character
        if (Regex.IsMatch(name, @"^[\-\._]"))
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = "Skin name starts with a special character.",
                InvolvedProperties = new List<string> { "Name" },
                SuggestedValues = new Dictionary<string, object?> { { "Name", name.TrimStart('-', '_', '.') } }
            });

        // Invalid characters (allow letters, digits, spaces, hyphens, underscores, dots)
        if (!Regex.IsMatch(name, @"^[a-zA-Z0-9 _\.\-]+$"))
            messages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = "Skin name contains invalid characters.",
                InvolvedProperties = new List<string> { "Name" },
                SuggestedValues = new Dictionary<string, object?> { { "Name", SanitizeName(name) } }
            });

        // Reserved names
        if (ReservedNames.Any(r => string.Equals(r, name, StringComparison.OrdinalIgnoreCase)))
            messages.Add(new SkinValidationMessage
            {
                IsError = true,
                Message = $"Skin name '{name}' is a reserved name.",
                InvolvedProperties = new List<string> { "Name" },
                SuggestedValues = new Dictionary<string, object?> { { "Name", name + " Custom" } }
            });

        // Generic names
        if (GenericNames.Any(g => string.Equals(g, name, StringComparison.OrdinalIgnoreCase)))
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = "Skin name is too generic.",
                InvolvedProperties = new List<string> { "Name" },
                SuggestedValues = new Dictionary<string, object?> { { "Name", name + " Custom" } }
            });

        // Quite long
        if (name.Length > QuiteLongThreshold)
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = "Skin name is quite long and may be hard to read.",
                InvolvedProperties = new List<string> { "Name" },
                SuggestedValues = new Dictionary<string, object?> { { "Name", name } }
            });

        // Problematic names
        if (ProblematicNames.Any(p => string.Equals(p, name, StringComparison.OrdinalIgnoreCase)))
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = "Skin name might be confusing (common debug/test name).",
                InvolvedProperties = new List<string> { "Name" },
                SuggestedValues = new Dictionary<string, object?> { { "Name", name + " Custom" } }
            });

        // Filesystem conflict patterns
        if (FilesystemConflictNames.Any(f => string.Equals(f, name, StringComparison.OrdinalIgnoreCase)))
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = "Skin name matches common reserved names in file systems.",
                InvolvedProperties = new List<string> { "Name" },
                SuggestedValues = new Dictionary<string, object?> { { "Name", name + " Skin" } }
            });

        // Short name not capitalized
        if (name.Length <= 3 && !char.IsUpper(name[0]))
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = "Short skin name should be capitalized.",
                InvolvedProperties = new List<string> { "Name" },
                SuggestedValues = new Dictionary<string, object?>
                    { { "Name", char.ToUpper(name[0]) + name.Substring(1) } }
            });

        // Contains version numbers (simple pattern vX.X or vX)
        if (Regex.IsMatch(name, @"\bv\d+(\.\d+)?\b", RegexOptions.IgnoreCase))
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = "Skin name contains version numbers.",
                InvolvedProperties = new List<string> { "Name" },
                SuggestedValues = new Dictionary<string, object?>
                    { { "Name", Regex.Replace(name, @"\bv\d+(\.\d+)?\b", "").Trim() } }
            });

        // Excessive capitalization
        if (name.Length >= 3 && name.All(char.IsUpper))
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = "Skin name has excessive capitalization.",
                InvolvedProperties = new List<string> { "Name" },
                SuggestedValues = new Dictionary<string, object?>
                    { { "Name", CultureInfo.CurrentCulture.TextInfo.ToTitleCase(name.ToLower()) } }
            });

        // Ends with "Theme" or "Skin"
        if (Regex.IsMatch(name, @"(Theme|Skin)$", RegexOptions.IgnoreCase))
            messages.Add(new SkinValidationMessage
            {
                IsError = false,
                Message = "Skin name ends with 'theme' or 'skin'.",
                InvolvedProperties = new List<string> { "Name" },
                SuggestedValues = new Dictionary<string, object?>
                    { { "Name", Regex.Replace(name, @"\b(Theme|Skin)$", "").Trim() } }
            });

        return messages;
    }

    private string SanitizeName(string name)
    {
        // Allow letters, digits, spaces, hyphens, underscores, dots
        var sanitized =
            new string(name.Where(c => char.IsLetterOrDigit(c) || c == ' ' || c == '-' || c == '_' || c == '.')
                .ToArray()).Trim();
        return sanitized.Length >= 3 ? sanitized : "Custom Skin";
    }
}